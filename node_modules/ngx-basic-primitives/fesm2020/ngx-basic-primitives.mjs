import * as i0 from '@angular/core';
import { Component, Input, ViewChild, EventEmitter, Output, Injectable, NgModule } from '@angular/core';
import { highestContrast, getFixOfPixelAlignment, getInnerSize, getElementOffset, OrgTaskManagerFactory, FamTaskManagerFactory } from 'basicprimitives';
import * as i10 from '@angular/common';
import { CommonModule } from '@angular/common';

/**
 * The enumeration sets leftward or rightward item placement relative to the referenced item.
 * In the case of assistants or advisers, the referenced node is their immediate parent.
 * In the case of the family diagram, the referenced node is a sibling.
 *
 * @enum {AdviserPlacementType}
 */
var AdviserPlacementType;
(function (AdviserPlacementType) {
    /**
     * Auto select by layout manager
     */
    AdviserPlacementType[AdviserPlacementType["Auto"] = 0] = "Auto";
    /**
     * Left side
     */
    AdviserPlacementType[AdviserPlacementType["Left"] = 2] = "Left";
    /**
     * Right side
     */
    AdviserPlacementType[AdviserPlacementType["Right"] = 3] = "Right";
})(AdviserPlacementType || (AdviserPlacementType = {}));
;
/**
 * Defines type of on-screen and in-layout annotation object. Annotations are geometrical
 * figures drawn around or bound to existing nodes of the diagram.
 *
 * @enum {AnnotationType}
 */
var AnnotationType;
(function (AnnotationType) {
    /**
     * The connector annotation displays a spline between two nodes of the diagram.
     * They are drawn on top and across the existing diagram layout, and they don't affect nodes placement.
     * If available space between nodes is not enough to display connector annotation,
     * then control draws it outside on the side of them.
     */
    AnnotationType[AnnotationType["Connector"] = 0] = "Connector";
    /**
     * Shape annotation is a possibility to draw some geometrical shapes over several nodes of the diagram.
     */
    AnnotationType[AnnotationType["Shape"] = 1] = "Shape";
    /**
     * Highlight path annotation traces a path between a given sequence of nodes over existing relation lines in the diagram.
     */
    AnnotationType[AnnotationType["HighlightPath"] = 2] = "HighlightPath";
    /**
     * The in-layout label annotation display values over relation lines between nodes.
     * The control preserves space for labels in the diagram layout so they don't overlap nodes.
     * Label annotations are designed for auto-placement and bundling of connection lines between nodes when needed.
     */
    AnnotationType[AnnotationType["Label"] = 3] = "Label";
    /**
     * The background annotation highlights nodes via drawing the rectangular shape in the node's background.
     * If the same style annotations of neighboring nodes overlap, control merges them into one continuous polygon geometry.
     */
    AnnotationType[AnnotationType["Background"] = 4] = "Background";
    /**
     * Level annotation highlights same level nodes of the diagram via drawing continuous rectangular shape
     * from side to side in their background. Level has optional title on the side of the diagram view area.
     * Title may be placed inside or outside of the diagram. If it is placed inside, it is drawn in the
     * background and does not occupy space.
     */
    AnnotationType[AnnotationType["Level"] = 5] = "Level";
})(AnnotationType || (AnnotationType = {}));
;
/**
 * The enumeration defines the shape of children's formation. By default, control places children in a horizontal
 * line below the parent node. On a large scale, this may result in the end-user having to scroll screens
 * to view all of them. To compensate, we provide the option of placing all of the children of a parent node
 * in a square/matrix formation. That will reduce sideways screen scrolling by compacting the child
 * nodes into a much smaller area on the screen.
 *
 * @enum {ChildrenPlacementType}
 */
var ChildrenPlacementType;
(function (ChildrenPlacementType) {
    /**
     * Auto = This mode lets you set nodes layout at the component level and then redefine it for individual nodes if needed.
     */
    ChildrenPlacementType[ChildrenPlacementType["Auto"] = 0] = "Auto";
    /**
     * Vertical layout
     */
    ChildrenPlacementType[ChildrenPlacementType["Vertical"] = 1] = "Vertical";
    /**
     * Horizontal layout
     */
    ChildrenPlacementType[ChildrenPlacementType["Horizontal"] = 2] = "Horizontal";
    /**
     * Matrix formation of the nodes
     */
    ChildrenPlacementType[ChildrenPlacementType["Matrix"] = 3] = "Matrix";
})(ChildrenPlacementType || (ChildrenPlacementType = {}));
;
/**
 * Just a list of named colors.
 *
 * @ignore
 * @enum {Colors}
 */
var Colors;
(function (Colors) {
    Colors["AliceBlue"] = "#f0f8ff";
    Colors["AntiqueWhite"] = "#faebd7";
    Colors["Aqua"] = "#00ffff";
    Colors["Aquamarine"] = "#7fffd4";
    Colors["Azure"] = "#f0ffff";
    Colors["Beige"] = "#f5f5dc";
    Colors["Bisque"] = "#ffe4c4";
    Colors["Black"] = "#000000";
    Colors["BlanchedAlmond"] = "#ffebcd";
    Colors["Blue"] = "#0000ff";
    Colors["BlueViolet"] = "#8a2be2";
    Colors["Brown"] = "#a52a2a";
    Colors["BurlyWood"] = "#deb887";
    Colors["Bronze"] = "#cd7f32";
    Colors["CadetBlue"] = "#5f9ea0";
    Colors["ChartReuse"] = "#7fff00";
    Colors["Chocolate"] = "#d2691e";
    Colors["Coral"] = "#ff7f50";
    Colors["CornflowerBlue"] = "#6495ed";
    Colors["Cornsilk"] = "#fff8dc";
    Colors["Crimson"] = "#dc143c";
    Colors["Cyan"] = "#00ffff";
    Colors["DarkBlue"] = "#00008b";
    Colors["DarkCyan"] = "#008b8b";
    Colors["DarkGoldenrod"] = "#b8860b";
    Colors["DarkGray"] = "#a9a9a9";
    Colors["DarkGreen"] = "#006400";
    Colors["DarkKhaki"] = "#bdb76b";
    Colors["DarkMagenta"] = "#8b008b";
    Colors["DarkOliveGreen"] = "#556b2f";
    Colors["Darkorange"] = "#ff8c00";
    Colors["DarkOrchid"] = "#9932cc";
    Colors["DarkRed"] = "#8b0000";
    Colors["DarkSalmon"] = "#e9967a";
    Colors["DarkSeaGreen"] = "#8fbc8f";
    Colors["DarkSlateBlue"] = "#483d8b";
    Colors["DarkSlateGray"] = "#2f4f4f";
    Colors["DarkTurquoise"] = "#00ced1";
    Colors["DarkViolet"] = "#9400d3";
    Colors["DeepPink"] = "#ff1493";
    Colors["DeepSkyBlue"] = "#00bfff";
    Colors["DimGray"] = "#696969";
    Colors["DodgerBlue"] = "#1e90ff";
    Colors["FireBrick"] = "#b22222";
    Colors["FloralWhite"] = "#fffaf0";
    Colors["ForestGreen"] = "#228b22";
    Colors["Fuchsia"] = "#ff00ff";
    Colors["Gainsboro"] = "#dcdcdc";
    Colors["GhostWhite"] = "#f8f8ff";
    Colors["Gold"] = "#ffd700";
    Colors["Goldenrod"] = "#daa520";
    Colors["Gray"] = "#808080";
    Colors["Green"] = "#008000";
    Colors["GreenYellow"] = "#adff2f";
    Colors["Honeydew"] = "#f0fff0";
    Colors["Hotpink"] = "#ff69b4";
    Colors["IndianRed"] = "#cd5c5c";
    Colors["Indigo"] = "#4b0082";
    Colors["Ivory"] = "#fffff0";
    Colors["Khaki"] = "#f0e68c";
    Colors["Lavender"] = "#e6e6fa";
    Colors["LavenderBlush"] = "#fff0f5";
    Colors["Lawngreen"] = "#7cfc00";
    Colors["Lemonchiffon"] = "#fffacd";
    Colors["LightBlue"] = "#add8e6";
    Colors["LightCoral"] = "#f08080";
    Colors["LightCyan"] = "#e0ffff";
    Colors["LightGoldenrodYellow"] = "#fafad2";
    Colors["LightGray"] = "#d3d3d3";
    Colors["LightGreen"] = "#90ee90";
    Colors["LightPink"] = "#ffb6c1";
    Colors["LightSalmon"] = "#ffa07a";
    Colors["LightSeaGreen"] = "#20b2aa";
    Colors["LightSkyBlue"] = "#87cefa";
    Colors["LightSlateGray"] = "#778899";
    Colors["LightSteelBlue"] = "#b0c4de";
    Colors["LightYellow"] = "#ffffe0";
    Colors["Lime"] = "#00ff00";
    Colors["Limegreen"] = "#32cd32";
    Colors["Linen"] = "#faf0e6";
    Colors["Magenta"] = "#ff00ff";
    Colors["Maroon"] = "#800000";
    Colors["MediumAquamarine"] = "#66cdaa";
    Colors["MediumBlue"] = "#0000cd";
    Colors["MediumOrchid"] = "#ba55d3";
    Colors["MediumPurple"] = "#9370d8";
    Colors["MediumSeaGreen"] = "#3cb371";
    Colors["MediumSlateBlue"] = "#7b68ee";
    Colors["MediumSpringGreen"] = "#00fa9a";
    Colors["MediumTurquoise"] = "#48d1cc";
    Colors["MediumVioletRed"] = "#c71585";
    Colors["MidnightBlue"] = "#191970";
    Colors["MintCream"] = "#f5fffa";
    Colors["MistyRose"] = "#ffe4e1";
    Colors["Moccasin"] = "#ffe4b5";
    Colors["NavajoWhite"] = "#ffdead";
    Colors["Navy"] = "#000080";
    Colors["Oldlace"] = "#fdf5e6";
    Colors["Olive"] = "#808000";
    Colors["Olivedrab"] = "#6b8e23";
    Colors["Orange"] = "#ffa500";
    Colors["OrangeRed"] = "#ff4500";
    Colors["Orchid"] = "#da70d6";
    Colors["PaleGoldenRod"] = "#eee8aa";
    Colors["PaleGreen"] = "#98fb98";
    Colors["PaleTurquoise"] = "#afeeee";
    Colors["PaleVioletRed"] = "#d87093";
    Colors["Papayawhip"] = "#ffefd5";
    Colors["Peachpuff"] = "#ffdab9";
    Colors["Peru"] = "#cd853f";
    Colors["Pink"] = "#ffc0cb";
    Colors["Plum"] = "#dda0dd";
    Colors["PowderBlue"] = "#b0e0e6";
    Colors["Purple"] = "#800080";
    Colors["Red"] = "#ff0000";
    Colors["RosyBrown"] = "#bc8f8f";
    Colors["RoyalBlue"] = "#4169e1";
    Colors["SaddleBrown"] = "#8b4513";
    Colors["Salmon"] = "#fa8072";
    Colors["SandyBrown"] = "#f4a460";
    Colors["SeaGreen"] = "#2e8b57";
    Colors["Seashell"] = "#fff5ee";
    Colors["Sienna"] = "#a0522d";
    Colors["Silver"] = "#c0c0c0";
    Colors["SkyBlue"] = "#87ceeb";
    Colors["SlateBlue"] = "#6a5acd";
    Colors["SlateGray"] = "#708090";
    Colors["Snow"] = "#fffafa";
    Colors["SpringGreen"] = "#00ff7f";
    Colors["SteelBlue"] = "#4682b4";
    Colors["Tan"] = "#d2b48c";
    Colors["Teal"] = "#008080";
    Colors["Thistle"] = "#d8bfd8";
    Colors["Tomato"] = "#ff6347";
    Colors["Turquoise"] = "#40e0d0";
    Colors["Violet"] = "#ee82ee";
    Colors["Wheat"] = "#f5deb3";
    Colors["White"] = "#ffffff";
    Colors["WhiteSmoke"] = "#f5f5f5";
    Colors["Yellow"] = "#ffff00";
    Colors["YellowGreen"] = "#9acd32";
})(Colors || (Colors = {}));
;
/**
 * Label placement relative to connector annotation. Connector annotation is bound and drawn between two nodes
 * defined by two properties = `fromItem` and `toItem`. Label can be placed close to "start", "end" nodes or in between of them
 *  along the connector line.
 *
 * @enum {ConnectorLabelPlacementType}
 */
var ConnectorLabelPlacementType;
(function (ConnectorLabelPlacementType) {
    ConnectorLabelPlacementType[ConnectorLabelPlacementType["From"] = 0] = "From";
    ConnectorLabelPlacementType[ConnectorLabelPlacementType["Between"] = 1] = "Between";
    ConnectorLabelPlacementType[ConnectorLabelPlacementType["To"] = 2] = "To";
})(ConnectorLabelPlacementType || (ConnectorLabelPlacementType = {}));
;
/**
 * Connector placement type defines style of connector line drawing over diagram layout. It supports two options =
 * the `Straight` is classic direct line connecting two nodes, this is the most expected style of connector annotation
 * drawing over diagram, the second style is called `Offbeat` and it design to dynamically adopt to nodes mutual
 * location and gap between them. It uses free hand line style drawing going from start to the end nodes. Since every diagram
 * is packed with various connection lines, this annotation placement style is deliberately made not straight, so it can be
 * noticeable on top of other lines of the diagram.
 *
 * @enum {ConnectorPlacementType}
 */
var ConnectorPlacementType;
(function (ConnectorPlacementType) {
    /**
     * Places connector annotation in the way that it does not overlap underlying diagram connector lines.
     * If nodes are close to each other and gap between them cannot fit annotation, then
     * it will be drawn on the side of the nodes, so it will have enough space for arrow and label.
     */
    ConnectorPlacementType[ConnectorPlacementType["Offbeat"] = 0] = "Offbeat";
    /**
     * Straight line annotation between nodes. This annotation mode provides basic conflict resolution between annotations
     * overlapping each other. If two or more straight annotations overlap each other then layout engine will
     * add extra offset to them, so they will be drawn in parallel to each other.
     */
    ConnectorPlacementType[ConnectorPlacementType["Straight"] = 1] = "Straight";
})(ConnectorPlacementType || (ConnectorPlacementType = {}));
;
/**
 * Connector shape type defines number of lines and arrows at their ends drawn between nodes of the connector annotation.
 * This feature combined with basic conflict resolution, which places overlapping annotations in parallel when they overlap each other,
 * gives you full flexibility over variations of possible connector lines between two given nodes of diagram.
 *
 * @enum {ConnectorShapeType}
 */
var ConnectorShapeType;
(function (ConnectorShapeType) {
    /**
     * Single line with one arrow
     */
    ConnectorShapeType[ConnectorShapeType["OneWay"] = 0] = "OneWay";
    /**
     * Two parallel lines with single arrows
     */
    ConnectorShapeType[ConnectorShapeType["TwoWay"] = 1] = "TwoWay";
    /**
     * Single line with 2 arrows.
     */
    ConnectorShapeType[ConnectorShapeType["BothWay"] = 2] = "BothWay";
})(ConnectorShapeType || (ConnectorShapeType = {}));
;
var ConnectorStyleType;
(function (ConnectorStyleType) {
    ConnectorStyleType[ConnectorStyleType["Extra"] = 0] = "Extra";
    ConnectorStyleType[ConnectorStyleType["Regular"] = 1] = "Regular";
    ConnectorStyleType[ConnectorStyleType["Highlight"] = 2] = "Highlight";
})(ConnectorStyleType || (ConnectorStyleType = {}));
;
/**
 * Connection lines style. This option is only applicable to nodes minimized to markers or lines.
 * Full size nodes are always connected with squared connection lines
 *
 * @enum {ConnectorType}
 */
var ConnectorType;
(function (ConnectorType) {
    /**
     * Orthogonal connection lines
     */
    ConnectorType[ConnectorType["Squared"] = 0] = "Squared";
    /**
     * Angular direct node to node connection lines
     */
    ConnectorType[ConnectorType["Angular"] = 1] = "Angular";
    /**
     * Curved direct node to node connection lines
     */
    ConnectorType[ConnectorType["Curved"] = 2] = "Curved";
})(ConnectorType || (ConnectorType = {}));
;
/**
 * Elbow style of connection lines
 *
 * @enum {ElbowType}
 */
var ElbowType;
(function (ElbowType) {
    /**
     * No elbow
     */
    ElbowType[ElbowType["None"] = 0] = "None";
    /**
     * Dot marker at the intersection
     */
    ElbowType[ElbowType["Dot"] = 1] = "Dot";
    /**
     * Bevel elbow
     */
    ElbowType[ElbowType["Bevel"] = 2] = "Bevel";
    /**
     * Round elbow
     */
    ElbowType[ElbowType["Round"] = 3] = "Round";
})(ElbowType || (ElbowType = {}));
;
/**
 * Defines option state.
 *
 * @readonly
 * @enum {number}
 */
var Enabled;
(function (Enabled) {
    /**
     * Option state is auto defined.
     */
    Enabled[Enabled["Auto"] = 0] = "Auto";
    /**
     * Enabled
     */
    Enabled[Enabled["True"] = 1] = "True";
    /**
     * Disabled
     */
    Enabled[Enabled["False"] = 2] = "False";
})(Enabled || (Enabled = {}));
;
/**
 * This enumeration defines objects gravity in the chart relative to parents and children.
 * For example connection lines can be drawn with arrows, so this enumeration controls
 * direction of arrows up towards parents or down towards children in the hierarchy.
 * The other example is nodes placement close to their immediate parents or immediate children
 * in case when parents and children are offset from them by multiple levels in hierarchy.
 *
 * @enum {GroupByType}
 */
var GroupByType;
(function (GroupByType) {
    GroupByType[GroupByType["None"] = 0] = "None";
    GroupByType[GroupByType["Parents"] = 1] = "Parents";
    GroupByType[GroupByType["Children"] = 2] = "Children";
})(GroupByType || (GroupByType = {}));
;
/**
 * Horizontal alignment
 *
 * @enum {HorizontalAlignmentType}
 */
var HorizontalAlignmentType;
(function (HorizontalAlignmentType) {
    HorizontalAlignmentType[HorizontalAlignmentType["Center"] = 0] = "Center";
    HorizontalAlignmentType[HorizontalAlignmentType["Left"] = 1] = "Left";
    HorizontalAlignmentType[HorizontalAlignmentType["Right"] = 2] = "Right";
})(HorizontalAlignmentType || (HorizontalAlignmentType = {}));
;
/**
 * The enumeration defines child node placement relative to its parent node.
 * By default, the control places all children that belong to the same parent as
 * the horizontal line below it. That works for a regular hierarchy of nodes
 * having the same type. In the organizational chart, we have a lot of exceptions
 * and non-hierarchical relations between nodes. For this purpose, we provide custom
 * item types to place nodes around the logical parent, which helps visually
 * differentiate nodes logically belonging to the same parent.  These placement
 * options give a lot of space for creating roles such as an Assistant, Adviser,
 * various Partners, and co-heads in the organization.  Additionally, control allows
 * shaping the same type of children into vertical and matrix formations
 * and place them into multiple levels.
 *
 * @enum {ItemType}
 */
var ItemType;
(function (ItemType) {
    /**
     * The regular type places node below parent.
     */
    ItemType[ItemType["Regular"] = 0] = "Regular";
    /**
     * The assistant type places node at the row on the side of the connection line going from parent to its children.
     */
    ItemType[ItemType["Assistant"] = 1] = "Assistant";
    /**
     * The sub-assistant node type is a variation of the assistant node type.
     * The sub-assistant places node at the row on the side of the connection line
     * going from parent to its children. The connection line goes out of the top side of the node.
     */
    ItemType[ItemType["SubAssistant"] = 4] = "SubAssistant";
    /**
     * The adviser type places node on the right or left side of the parent.
     */
    ItemType[ItemType["Adviser"] = 2] = "Adviser";
    /**
     * The sub-adviser type places node on the right or left side of the parent.
     * The connection line goes out of the top side of the sub-adviser node.
     */
    ItemType[ItemType["SubAdviser"] = 5] = "SubAdviser";
    /**
     * The general partner type is an imitation of multiple inheritances in the organizational chart hierarchy.
     * The general-partner node is drawn side by side with its logical parent, and control places
     * regular children below them, so they visually look like parents. Another layout specifics
     * of the general partner is that it is connected to its logical parent's parent.
     * So visually, it becomes an immediate child of its grandparent.
     */
    ItemType[ItemType["GeneralPartner"] = 6] = "GeneralPartner";
    /**
     * The limited partner is a variation of the general partner.
     * The only difference is that it is not connected to its logical grandparent.
     */
    ItemType[ItemType["LimitedPartner"] = 7] = "LimitedPartner";
    /**
     * The adviser partner is a variation of the limited partner.
     * The difference is that it has an extra connection line to its logical parent.
     */
    ItemType[ItemType["AdviserPartner"] = 8] = "AdviserPartner";
})(ItemType || (ItemType = {}));
;
var LabelType;
(function (LabelType) {
    LabelType[LabelType["Regular"] = 0] = "Regular";
    LabelType[LabelType["Dummy"] = 1] = "Dummy";
    LabelType[LabelType["Fixed"] = 2] = "Fixed";
    LabelType[LabelType["None"] = 3] = "None";
})(LabelType || (LabelType = {}));
;
var Layers;
(function (Layers) {
    Layers[Layers["LevelAnnotation"] = 1] = "LevelAnnotation";
    Layers[Layers["BackgroundAnnotation"] = 2] = "BackgroundAnnotation";
    Layers[Layers["BackgroundAnnotations"] = 3] = "BackgroundAnnotations";
    Layers[Layers["BackgroundConnectorAnnotation"] = 4] = "BackgroundConnectorAnnotation";
    Layers[Layers["BackgroundHighlightPathAnnotations"] = 5] = "BackgroundHighlightPathAnnotations";
    Layers[Layers["Connector"] = 6] = "Connector";
    Layers[Layers["ForegroundHighlightPathAnnotations"] = 7] = "ForegroundHighlightPathAnnotations";
    Layers[Layers["Highlight"] = 8] = "Highlight";
    Layers[Layers["Marker"] = 9] = "Marker";
    Layers[Layers["Label"] = 10] = "Label";
    Layers[Layers["Cursor"] = 11] = "Cursor";
    Layers[Layers["Item"] = 12] = "Item";
    Layers[Layers["ForegroundAnnotations"] = 13] = "ForegroundAnnotations";
    Layers[Layers["ForegroundConnectorAnnotation"] = 14] = "ForegroundConnectorAnnotation";
    Layers[Layers["Annotation"] = 15] = "Annotation";
    Layers[Layers["Controls"] = 16] = "Controls";
})(Layers || (Layers = {}));
;
/**
 * Line style of connection lines.
 *
 * @enum {LineType}
 */
var LineType;
(function (LineType) {
    LineType[LineType["Solid"] = 0] = "Solid";
    LineType[LineType["Dotted"] = 1] = "Dotted";
    LineType[LineType["Dashed"] = 2] = "Dashed";
})(LineType || (LineType = {}));
;
/**
 * Interactivity mode. Control implements standard behavior of classic desktop UI controls. It supports single selected node - cursor.
 * It supports on mouse over node visual feedback - highlight. It supports selection of group of nodes - selected items.
 * All that functionality can be disabled depending on your application requirements.
 *
 * @enum {NavigationMode}
 */
var NavigationMode;
(function (NavigationMode) {
    /**
     * Everything is on.
     */
    NavigationMode[NavigationMode["Default"] = 0] = "Default";
    /**
     * Cursor selection only without highlight.
     */
    NavigationMode[NavigationMode["CursorOnly"] = 1] = "CursorOnly";
    /**
     * Mouse over feedback only
     */
    NavigationMode[NavigationMode["HighlightOnly"] = 3] = "HighlightOnly";
    /**
     * No interactivity
     */
    NavigationMode[NavigationMode["Inactive"] = 2] = "Inactive";
})(NavigationMode || (NavigationMode = {}));
;
/**
 * Neighbors selection mode. The control supports diagram auto fit into screen view. It is achieved via drawing nodes in form of markers.
 * So small nodes make diagram fit into the screen space, but they have no details. Our solution is to show cursor and selected items
 * of the diagram in full size and draw all other as markers.
 *
 * This enumeration controls visibility of neighbors of the cursor node in the auto fit mode. It allows to draw
 * them in full size regardless of available space.
 *
 * @enum {NavigationMode}
 */
var NeighboursSelectionMode;
(function (NeighboursSelectionMode) {
    /**
     * Selects parents and children of the cursor item
     */
    NeighboursSelectionMode[NeighboursSelectionMode["ParentsAndChildren"] = 0] = "ParentsAndChildren";
    /**
     * Selects parents, children, and siblings of the cursor item.
     */
    NeighboursSelectionMode[NeighboursSelectionMode["ParentsChildrenSiblingsAndSpouses"] = 1] = "ParentsChildrenSiblingsAndSpouses";
})(NeighboursSelectionMode || (NeighboursSelectionMode = {}));
;
/**
 * Controls diagram layout orientation. The control can be rotated in any direction, this is needed for arabic support and various layout.
 *
 * @enum {OrientationType}
 */
var OrientationType;
(function (OrientationType) {
    OrientationType[OrientationType["Top"] = 0] = "Top";
    OrientationType[OrientationType["Bottom"] = 1] = "Bottom";
    OrientationType[OrientationType["Left"] = 2] = "Left";
    OrientationType[OrientationType["Right"] = 3] = "Right";
    OrientationType[OrientationType["None"] = 4] = "None";
})(OrientationType || (OrientationType = {}));
;
/**
 * Fits diagram into available screen space. When diagram size significantly larger that available screen space, its scrolling and navigation
 * becomes problematic, so we support automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.
 * Control supports several page fit mode options which can match your requirements depending on diagram layout, orientation and number of nodes.
 *
 * Autosize - this option is opposite to auto fit. It lets you expand control size to fit all diagram nodes full size without scroll bars.
 *
 * @enum {PageFitMode}
 */
var PageFitMode;
(function (PageFitMode) {
    /**
     * Disabled. All nodes are being rendered using their templates.
     */
    PageFitMode[PageFitMode["None"] = 0] = "None";
    /**
     * Fits diagram into the view width, so it has no horizontal scrollbar.
     */
    PageFitMode[PageFitMode["PageWidth"] = 1] = "PageWidth";
    /**
     * Fits diagram into the view hight, so it has no vertical scrollbar.
     */
    PageFitMode[PageFitMode["PageHeight"] = 2] = "PageHeight";
    /**
     * Fits diagram into the view so it has no scroll bars.
     */
    PageFitMode[PageFitMode["FitToPage"] = 3] = "FitToPage";
    /**
     * This is opposite mode to auto fit. In this mode diagram controls its size, it sets its size to fit all nodes and render them full size using templates.
     */
    PageFitMode[PageFitMode["AutoSize"] = 5] = "AutoSize";
    /**
     * Renders all nodes as markers regardless of available screen space. Control selects and renders full size cursor, its neighbours and selected nodes only.
     * Don't forget to disable selection path as well, so nodes from cursor up to the root are not selected.
     */
    PageFitMode[PageFitMode["SelectionOnly"] = 6] = "SelectionOnly";
})(PageFitMode || (PageFitMode = {}));
;
/**
 * Defines element placement relative to rectangular area it is bound to.
 *
 * @enum {PlacementType}
 */
var PlacementType;
(function (PlacementType) {
    /**
     * Defined by other control options.
     */
    PlacementType[PlacementType["Auto"] = 0] = "Auto";
    PlacementType[PlacementType["TopLeft"] = 8] = "TopLeft";
    PlacementType[PlacementType["Top"] = 1] = "Top";
    PlacementType[PlacementType["TopRight"] = 2] = "TopRight";
    PlacementType[PlacementType["RightTop"] = 11] = "RightTop";
    PlacementType[PlacementType["Right"] = 3] = "Right";
    PlacementType[PlacementType["RightBottom"] = 12] = "RightBottom";
    PlacementType[PlacementType["BottomRight"] = 4] = "BottomRight";
    PlacementType[PlacementType["Bottom"] = 5] = "Bottom";
    PlacementType[PlacementType["BottomLeft"] = 6] = "BottomLeft";
    PlacementType[PlacementType["LeftBottom"] = 10] = "LeftBottom";
    PlacementType[PlacementType["Left"] = 7] = "Left";
    PlacementType[PlacementType["LeftTop"] = 9] = "LeftTop";
})(PlacementType || (PlacementType = {}));
;
/**
 * This enumeration is used to tell rendering callback functions current state of the template.
 * It is needed for proper events binding and content updates.
 *
 * @enum {RenderingMode}
 */
var RenderingMode;
(function (RenderingMode) {
    /**
     * Template is just created.
     */
    RenderingMode[RenderingMode["Create"] = 0] = "Create";
    /**
     * Template is reused and update is needed.
     */
    RenderingMode[RenderingMode["Update"] = 1] = "Update";
})(RenderingMode || (RenderingMode = {}));
;
var SegmentType;
(function (SegmentType) {
    SegmentType[SegmentType["Line"] = 0] = "Line";
    SegmentType[SegmentType["Move"] = 1] = "Move";
    SegmentType[SegmentType["QuadraticArc"] = 2] = "QuadraticArc";
    SegmentType[SegmentType["CubicArc"] = 3] = "CubicArc";
    SegmentType[SegmentType["Dot"] = 4] = "Dot";
})(SegmentType || (SegmentType = {}));
;
/**
 * Selection path mode. This enumeration controls visibility of nodes between cursor and the root of the diagram in the auto fit mode. It allows to draw
 * them in full size regardless of available space and auto fit mode.
 *
 * The control supports diagram auto fit into screen view. It is achieved via drawing nodes in form of markers.
 * So small nodes make diagram fit into the screen space, but they have no details. Our solution is to show cursor and selected items
 * of the diagram in full size and draw all other diagram nodes as markers.
 *
 * @enum {SelectionPathMode}
 */
var SelectionPathMode;
(function (SelectionPathMode) {
    /**
     * No selection path
     */
    SelectionPathMode[SelectionPathMode["None"] = 0] = "None";
    /**
     * Selects cursor node parents up to the root are renders them full size regardless of available space.
     */
    SelectionPathMode[SelectionPathMode["FullStack"] = 1] = "FullStack";
})(SelectionPathMode || (SelectionPathMode = {}));
;
/**
 * Shapes
 *
 * @enum {ShapeType}
 */
var ShapeType;
(function (ShapeType) {
    ShapeType[ShapeType["Rectangle"] = 0] = "Rectangle";
    ShapeType[ShapeType["Oval"] = 1] = "Oval";
    ShapeType[ShapeType["Triangle"] = 2] = "Triangle";
    ShapeType[ShapeType["CrossOut"] = 3] = "CrossOut";
    ShapeType[ShapeType["Circle"] = 4] = "Circle";
    ShapeType[ShapeType["Rhombus"] = 5] = "Rhombus";
    ShapeType[ShapeType["Wedge"] = 7] = "Wedge";
    ShapeType[ShapeType["FramedOval"] = 8] = "FramedOval";
    ShapeType[ShapeType["FramedTriangle"] = 9] = "FramedTriangle";
    ShapeType[ShapeType["FramedWedge"] = 10] = "FramedWedge";
    ShapeType[ShapeType["FramedRhombus"] = 11] = "FramedRhombus";
    ShapeType[ShapeType["None"] = 6] = "None";
})(ShapeType || (ShapeType = {}));
;
var SideFlag;
(function (SideFlag) {
    SideFlag[SideFlag["Top"] = 1] = "Top";
    SideFlag[SideFlag["Right"] = 2] = "Right";
    SideFlag[SideFlag["Bottom"] = 4] = "Bottom";
    SideFlag[SideFlag["Left"] = 8] = "Left";
})(SideFlag || (SideFlag = {}));
;
/**
 * Text rotation
 *
 * @enum {TextOrientationType}
 */
var TextOrientationType;
(function (TextOrientationType) {
    /**
     * Regular horizontal text
     */
    TextOrientationType[TextOrientationType["Horizontal"] = 0] = "Horizontal";
    /**
     * Rotate text left for 90 degree.
     */
    TextOrientationType[TextOrientationType["RotateLeft"] = 1] = "RotateLeft";
    /**
     * Rotate text right for 90 degree.
     */
    TextOrientationType[TextOrientationType["RotateRight"] = 2] = "RotateRight";
    /**
     * Depends on other options.
     */
    TextOrientationType[TextOrientationType["Auto"] = 3] = "Auto";
})(TextOrientationType || (TextOrientationType = {}));
;
/**
 * Controls update of the diagram
 *
 * @enum {UpdateMode}
 */
var UpdateMode;
(function (UpdateMode) {
    /**
     * Forces control to make a full chart redraw. It is equivalent to initial chart creation.
     * It removes everything from placeholder and renders all elements again.
     */
    UpdateMode[UpdateMode["Recreate"] = 0] = "Recreate";
    /**
     * Optimized refresh. It only updates visual elements which needs to be updated.
     */
    UpdateMode[UpdateMode["Refresh"] = 1] = "Refresh";
    /**
     * Updates highlight position only
     */
    UpdateMode[UpdateMode["PositonHighlight"] = 2] = "PositonHighlight";
})(UpdateMode || (UpdateMode = {}));
;
/**
 * Defines relation between two vectors
 *
 * @enum {VectorRelationType}
 */
var VectorRelationType;
(function (VectorRelationType) {
    VectorRelationType[VectorRelationType["None"] = 0] = "None";
    VectorRelationType[VectorRelationType["Null"] = 1] = "Null";
    VectorRelationType[VectorRelationType["Collinear"] = 2] = "Collinear";
    VectorRelationType[VectorRelationType["Opposite"] = 3] = "Opposite";
})(VectorRelationType || (VectorRelationType = {}));
;
/**
 * Controls nodes vertical alignment inside row of nodes. If row of nodes contains nodes of
 * multiple sizes then small nodes are vertically aligned relative to their large neighbours.
 *
 * @enum {VerticalAlignmentType}
 */
var VerticalAlignmentType;
(function (VerticalAlignmentType) {
    VerticalAlignmentType[VerticalAlignmentType["Top"] = 0] = "Top";
    VerticalAlignmentType[VerticalAlignmentType["Middle"] = 1] = "Middle";
    VerticalAlignmentType[VerticalAlignmentType["Bottom"] = 2] = "Bottom";
})(VerticalAlignmentType || (VerticalAlignmentType = {}));
;
/**
 * Minimal nodes visibility in the diagram. If auto fit of diagram into current page size is enabled, then
 * this option controls minimum allowed size of diagram nodes.
 *
 * @enum {Visibility}
 */
var Visibility;
(function (Visibility) {
    /**
     * Selects best visibility mode.
     */
    Visibility[Visibility["Auto"] = 0] = "Auto";
    /**
     * Regular template based diagram nodes
     */
    Visibility[Visibility["Normal"] = 1] = "Normal";
    /**
     * Diagram draws nodes in form of markers
     */
    Visibility[Visibility["Dot"] = 2] = "Dot";
    /**
     * Diagram only draws connection lines and hides actual nodes.
     */
    Visibility[Visibility["Line"] = 3] = "Line";
    /**
     * Makes node invisible in layout. If node has no parents then
     * its connection lines are hidden as well.
     *
     * @ignore
     */
    Visibility[Visibility["Invisible"] = 4] = "Invisible";
})(Visibility || (Visibility = {}));
;
/**
 * Option to draw annotation in the foreground or in the background of diagram nodes.
 *
 * @enum {ZOrderType}
 */
var ZOrderType;
(function (ZOrderType) {
    /**
     * Depends on annotation type.
     */
    ZOrderType[ZOrderType["Auto"] = 0] = "Auto";
    /**
     * Background
     */
    ZOrderType[ZOrderType["Background"] = 1] = "Background";
    /**
     * Foreground
     */
    ZOrderType[ZOrderType["Foreground"] = 2] = "Foreground";
})(ZOrderType || (ZOrderType = {}));
;

class Rect {
    constructor(x = 0, y = 0, width = 0, height = 0, context = null) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    translate(x, y) {
        this.x = this.x + x;
        this.y = this.y + y;
        return this;
    }
    ;
    getCSS(units = "px") {
        var result = {
            left: this.x + units,
            top: this.y + units,
            width: this.width + units,
            height: this.height + units
        };
        return result;
    }
    ;
}
;

class Size {
    constructor(width = 0, height = 0) {
        this.width = 0;
        this.height = 0;
        this.width = width;
        this.height = height;
    }
    getCSS(units = "px") {
        var result = {
            width: this.width + units,
            height: this.height + units
        };
        return result;
    }
    ;
    space() {
        return this.width * this.height;
    }
    ;
}

class Thickness {
    constructor(left, top, right, bottom) {
        this.left = 0;
        this.top = 0;
        this.right = 0;
        this.bottom = 0;
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }
}

class Point {
    constructor(x = 0, y = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x;
        this.y = y;
    }
    getCSS(units = "px") {
        var result = {
            left: this.x + units,
            top: this.y + units
        };
        return result;
    }
    ;
}

class Path {
    constructor(data, style) {
        this.data = data;
        this.style = style;
    }
}

class Label {
    constructor(label, width, height, orientation, horizontalAlignment, verticalAlignment, style) {
        this.label = label;
        this.width = width;
        this.height = height;
        this.orientation = orientation;
        this.horizontalAlignment = horizontalAlignment;
        this.verticalAlignment = verticalAlignment;
        this.style = style;
    }
}

class Template {
    constructor(templateType, name, templateRef, context, style) {
        this.templateType = templateType;
        this.name = name;
        this.templateRef = templateRef;
        this.context = context;
        this.style = style;
    }
}

class Placeholder {
    constructor(name) {
        this.layers = [];
        this.activeLayer = null;
        this.size = new Size();
        this.rect = new Rect();
        this.hasGraphics = true;
        this.isVisible = true;
        this.name = name;
        this.layers = [];
        this.activeLayer = null;
    }
}

class Layer {
    constructor(name) {
        this.items = [];
        this.polylines = [];
        this.labels = [];
        this.name = name;
    }
    reset() {
        this.items = [];
        this.polylines = [];
        this.labels = [];
    }
}

class Graphics {
    constructor(size) {
        this.placeholders = {};
        this.activePlaceholder = null;
        this.hasGraphics = true;
        this.names = [];
        this.size = size;
        this.names = [];
        for (var layer in Layers) {
            let value = parseInt(Layers[layer]);
            this.names[value] = layer;
        }
        ;
    }
    clean() {
        this.placeholders = {};
        this.activePlaceholder = null;
    }
    resize(name, width, height) {
        this.activatePlaceholder(name);
        this.resizePlaceholder(this.activePlaceholder, 0, 0, width, height);
    }
    ;
    position(name, left, top, width, height) {
        this.activatePlaceholder(name);
        this.resizePlaceholder(this.activePlaceholder, left, top, width, height);
    }
    ;
    show(name) {
        var placeholder = this.placeholders[name];
        if (placeholder != null) {
            placeholder.isVisible = true;
        }
    }
    ;
    hide(name) {
        var placeholder = this.placeholders[name];
        if (placeholder != null) {
            placeholder.isVisible = false;
        }
    }
    ;
    resizePlaceholder(placeholder, left, top, width, height) {
        placeholder.size = new Size(width, height);
        placeholder.rect = new Rect(left, top, width, height);
    }
    ;
    reset(placeholderName, layerKey) {
        const placeholder = this.placeholders[placeholderName];
        if (placeholder != null) {
            const layer = placeholder.layers[layerKey];
            if (layer != null) {
                layer.reset();
            }
        }
    }
    ;
    activate(placeholderName, layerKey) {
        this.activatePlaceholder(placeholderName);
        this.activateLayer(layerKey);
        return this.activePlaceholder;
    }
    ;
    activatePlaceholder(name) {
        let placeholder = this.placeholders[name];
        if (placeholder === undefined) {
            placeholder = new Placeholder(name);
            placeholder.size = this.size;
            placeholder.rect = new Rect(0, 0, placeholder.size.width, placeholder.size.height);
            this.placeholders[name] = placeholder;
        }
        this.activePlaceholder = placeholder;
    }
    ;
    activateLayer(layerKey) {
        const name = this.names[layerKey];
        if (!this.activePlaceholder) {
            throw "No active placeholder";
        }
        let layer = this.activePlaceholder.layers[layerKey];
        if (layer === undefined) {
            layer = new Layer(name);
            this.activePlaceholder.layers[layerKey] = layer;
        }
        this.activePlaceholder.activeLayer = layer;
    }
    ;
    getPlaceholders() {
        return this.placeholders;
    }
    text(x, y, width, height, label, orientation, horizontalAlignment, verticalAlignment, attr) {
        if (!this.activePlaceholder || !this.activePlaceholder.activeLayer) {
            throw "No active placeholder or layer";
        }
        this.activePlaceholder.activeLayer.labels.push(new Label(label, width, height, orientation, horizontalAlignment, verticalAlignment, {
            ...attr,
            top: y + "px",
            left: x + "px"
        }));
    }
    ;
    polyline(polylineData) {
        if (!this.activePlaceholder || !this.activePlaceholder.activeLayer) {
            throw "No active placeholder or layer";
        }
        var attr = polylineData.paletteItem.toAttr(), step, radius, cornerRadius, style = {};
        if (attr.fillColor !== undefined) {
            style.fill = attr.fillColor;
            style.fillOpacity = attr.opacity;
        }
        else {
            style.fillOpacity = 0;
        }
        if (attr.lineWidth !== undefined && attr.borderColor !== undefined) {
            style.stroke = attr.borderColor;
            style.strokeWidth = attr.lineWidth;
            if (attr.opacity !== undefined) {
                style.strokeOpacity = attr.opacity;
            }
            else {
                style.strokeOpacity = 1;
            }
        }
        else {
            style.stroke = "transparent";
            style.strokeWidth = 0;
        }
        if (attr.lineType != null) {
            step = Math.round(attr.lineWidth) || 1;
            switch (attr.lineType) {
                case LineType.Dotted:
                    style.strokeDasharray = step + "," + step;
                    break;
                case LineType.Dashed:
                    style.strokeDasharray = (step * 5) + "," + (step * 3);
                    break;
                case LineType.Solid:
                default:
                    style.strokeDasharray = "";
                    break;
            }
        }
        let data = "";
        polylineData.loop(this, function (segment) {
            switch (segment.segmentType) {
                case SegmentType.Move:
                    data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                    break;
                case SegmentType.Line:
                    data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                    break;
                case SegmentType.QuadraticArc:
                    data += "Q" + (Math.round(segment.cpX) + 0.5) + " " + (Math.round(segment.cpY) + 0.5) + " " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                    break;
                case SegmentType.Dot:
                    // A rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y
                    if (segment.width === segment.height && segment.width / 2.0 <= segment.cornerRadius) {
                        // dot
                        radius = segment.width / 2.0;
                        data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2.0 + 0.5);
                        data += "A" + radius + " " + radius + " 0 0 0 " + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2.0 + 0.5);
                        data += "A" + radius + " " + radius + " 0 0 0 " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + segment.height / 2.0 + 0.5);
                    }
                    else if (segment.cornerRadius === 0) {
                        // square
                        data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                        data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                        data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
                        data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
                        data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                    }
                    else {
                        cornerRadius = Math.min(segment.cornerRadius, Math.min(segment.width / 2.0, segment.height / 2.0));
                        data += "M" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
                        data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + cornerRadius) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                        data += "L" + (Math.round(segment.x + segment.width - cornerRadius) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                        data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
                        data += "L" + (Math.round(segment.x + segment.width) + 0.5) + " " + (Math.round(segment.y + segment.height - cornerRadius) + 0.5);
                        data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x + segment.width - cornerRadius) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
                        data += "L" + (Math.round(segment.x + cornerRadius) + 0.5) + " " + (Math.round(segment.y + segment.height) + 0.5);
                        data += "A" + Math.round(cornerRadius) + " " + Math.round(cornerRadius) + " 0 0 1 " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + segment.height - cornerRadius) + 0.5);
                        data += "L" + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y + cornerRadius) + 0.5);
                    }
                    break;
                case SegmentType.CubicArc:
                    data += "C" + (Math.round(segment.cpX1) + 0.5) + " " + (Math.round(segment.cpY1) + 0.5) +
                        " " + (Math.round(segment.cpX2) + 0.5) + " " + (Math.round(segment.cpY2) + 0.5) +
                        " " + (Math.round(segment.x) + 0.5) + " " + (Math.round(segment.y) + 0.5);
                    break;
                default:
                    break;
            }
        });
        this.activePlaceholder.activeLayer.polylines.push(new Path(data, style));
    }
    ;
    polylinesBuffer(buffer) {
        var thisArg = this;
        buffer.loop(this, function (item) {
            if (item.length() > 0) {
                thisArg.polyline(item);
            }
        });
    }
    ;
    template(x, y, width, height, contentX, contentY, contentWidth, contentHeight, options, _hashCode, onRenderTemplate, uiHash, attr) {
        if (!this.activePlaceholder || !this.activePlaceholder.activeLayer) {
            throw "No active placeholder or layer";
        }
        const left = x + contentX, top = y + contentY, templateWidth = contentWidth, templateHeight = contentHeight;
        let style = {
            "width": templateWidth + "px",
            "height": templateHeight + "px",
            "top": top + "px",
            "left": left + "px",
            ...attr
        };
        var context = {
            ...uiHash,
            ...options,
            x: left,
            y: top,
            width: templateWidth,
            height: templateHeight
        };
        var templateRef = null;
        if (onRenderTemplate !== null) {
            templateRef = onRenderTemplate(context);
        }
        ;
        // if(options.templateType == "labelAnnotationTemplate") {
        //   console.log("template type:" + options.templateType);
        //   console.log(JSON.stringify(context));
        // }
        this.activePlaceholder.activeLayer.items.push(new Template(options.templateType, options.templateName, templateRef, context, style));
    }
    ;
    getPxSize(value, base) {
        var result = value;
        if (typeof value === "string") {
            if (value.indexOf("pt") > 0) {
                result = parseInt(value, 10) * 96 / 72;
            }
            else if (value.indexOf("%") > 0) {
                result = parseFloat(value) / 100.0 * base;
            }
            else {
                result = parseInt(value, 10);
            }
        }
        return result;
    }
    ;
}
;

class AbstractTemplate {
    constructor(templateType, options) {
        this.options = {
            ...options,
            templateType
        };
    }
    template() {
        return this.options;
    }
    getHashCode() {
        return "";
    }
    render(data) {
        return null;
    }
    ;
}
;

class AnnotationLabelTemplate extends AbstractTemplate {
    constructor() {
        super("annotationLabelTemplate", {});
    }
}
;

class ButtonsTemplate extends AbstractTemplate {
    constructor() {
        super("dummyTemplate", {});
    }
    ;
    render(data) {
        const { onButtonsRender } = data;
        return onButtonsRender();
    }
    ;
}
;

class CheckBoxTemplate extends AbstractTemplate {
    constructor(selectCheckBoxLabel) {
        super("checkboxTemplate", { selectCheckBoxLabel });
    }
}
;

class CursorTemplate extends AbstractTemplate {
    constructor(options, templateConfig) {
        super("cursorTemplate", {
            ...options,
            templateConfig
        });
    }
}
;

class CustomRenderTemplate extends AbstractTemplate {
    constructor(options, onRender) {
        super("dummyTemplate", options);
        this.render = onRender;
    }
}
;

class DotHighlightTemplate extends AbstractTemplate {
    constructor(options, templateConfig) {
        super("dotHighlightTemplate", {
            ...options,
            templateConfig
        });
    }
}
;

class GroupTitleTemplate extends AbstractTemplate {
    constructor(options) {
        super("groupTitleTemplate", options);
    }
}
;

class HighlightTemplate extends AbstractTemplate {
    constructor(options, templateConfig) {
        super("highlightTemplate", {
            ...options,
            templateConfig
        });
    }
}
;

class ItemTemplate extends AbstractTemplate {
    constructor(options, templateConfig) {
        super("itemTemplate", {
            ...options,
            templateConfig
        });
    }
}
;

class LabelAnnotationTemplate extends AbstractTemplate {
    constructor() {
        super("labelAnnotationTemplate", {});
    }
}
;

class LevelBackgroundTemplate extends AbstractTemplate {
    constructor(options) {
        super("levelBackgroundTemplate", options);
    }
}
;

class LevelTitleTemplate extends AbstractTemplate {
    constructor(options, orientation) {
        var levelTitleOrientation = options.levelTitleOrientation;
        if (options.levelTitleOrientation == TextOrientationType.Auto) {
            switch (orientation) {
                case OrientationType.Top:
                    levelTitleOrientation = TextOrientationType.RotateRight;
                    break;
                case OrientationType.Bottom:
                    levelTitleOrientation = TextOrientationType.RotateRight;
                    break;
                default:
                    break;
            }
        }
        super("levelTitleTemplate", {
            ...options,
            orientation,
            levelTitleOrientation
        });
    }
}
;

class UserTemplate extends AbstractTemplate {
    constructor(options, itemTemplate, onRender) {
        super("dummyTemplate", {
            ...options,
            itemTemplate
        });
        this.render = onRender;
    }
}
;

class TaskManagerFactory {
    constructor(factory) {
        this.factory = factory;
    }
}

class RotatedText {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.orientation = TextOrientationType.RotateRight;
        this.horizontalAlignment = HorizontalAlignmentType.Center;
        this.verticalAlignment = VerticalAlignmentType.Middle;
        this.hasVerticalAlignment = false;
        this.tableStyle = {};
        this.tdStyle = {};
        this.divStyle = {};
    }
    ngOnChanges() {
        const transform = this.getTransform(this.orientation);
        let size = {};
        if (this.orientation === TextOrientationType.Horizontal) {
            size = {
                width: this.width + "px",
                height: this.height + "px",
                maxWidth: this.width + "px",
                maxHeight: this.height + "px"
            };
        }
        else {
            size = {
                width: this.height + "px",
                height: this.width + "px",
                maxWidth: this.height + "px",
                maxHeight: this.width + "px",
                left: Math.round(this.width / 2.0 - this.height / 2.0) + "px",
                top: Math.round(this.height / 2.0 - this.width / 2.0) + "px"
            };
        }
        var style = {
            position: "absolute",
            padding: 0,
            margin: 0,
            lineHeight: 1,
            textAlign: this.getHorizontalAlignment(this.horizontalAlignment),
            WebkitTransformOrigin: "center center",
            MozTransformOrigin: "center center",
            OTransformOrigin: "center center",
            msTransformOrigin: "center center",
            WebkitTransform: transform,
            MozTransform: transform,
            OTransform: transform,
            msTransform: transform,
            transform: transform,
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            overflow: "hidden",
            tableLayout: "fixed",
            ...size
        };
        this.hasVerticalAlignment = this.verticalAlignment !== VerticalAlignmentType.Top;
        this.tdStyle = {
            'verticalAlign': this.getVerticalAlignment(this.verticalAlignment),
            'padding': 0,
            'textOverflow': 'ellipsis',
            'whiteSpace': 'nowrap',
            'overflow': 'hidden'
        };
        this.tableStyle = {
            ...style,
            borderCollapse: "collapse"
        };
        this.divStyle = style;
    }
    getTransform(orientation) {
        let result = "";
        switch (orientation) {
            case TextOrientationType.RotateLeft:
                result = "rotate(-90deg)";
                break;
            case TextOrientationType.RotateRight:
                result = "rotate(90deg)";
                break;
            default:
                break;
        }
        return result;
    }
    getHorizontalAlignment(horizontalAlignment) {
        let result = "";
        switch (horizontalAlignment) {
            case HorizontalAlignmentType.Center:
                result = 'center';
                break;
            case HorizontalAlignmentType.Left:
                result = 'left';
                break;
            case HorizontalAlignmentType.Right:
                result = 'right';
                break;
        }
        return result;
    }
    getVerticalAlignment(verticalAlignment) {
        let result = "";
        switch (verticalAlignment) {
            case VerticalAlignmentType.Bottom:
                result = 'bottom';
                break;
            case VerticalAlignmentType.Middle:
                result = 'middle';
                break;
            case VerticalAlignmentType.Top:
                result = 'top';
                break;
        }
        return result;
    }
}
RotatedText.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: RotatedText, deps: [], target: i0.ɵɵFactoryTarget.Component });
RotatedText.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: RotatedText, selector: "rotated-text", inputs: { width: "width", height: "height", orientation: "orientation", horizontalAlignment: "horizontalAlignment", verticalAlignment: "verticalAlignment" }, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"hasVerticalAlignment; then tableTemplate; else divTemplate\"></div>\r\n<ng-template #tableTemplate>\r\n  <table [ngStyle]=\"tableStyle\">\r\n    <tbody>\r\n      <tr>\r\n        <td [ngStyle]=\"tdStyle\">\r\n          <ng-container *ngTemplateOutlet=\"content\"></ng-container>\r\n        </td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</ng-template>\r\n<ng-template #divTemplate>\r\n  <div [ngStyle]=\"divStyle\">\r\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\r\n  </div>\r\n</ng-template>\r\n<ng-template #content><ng-content></ng-content></ng-template>", styles: [""], directives: [{ type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i10.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: RotatedText, decorators: [{
            type: Component,
            args: [{ selector: 'rotated-text', template: "<div *ngIf=\"hasVerticalAlignment; then tableTemplate; else divTemplate\"></div>\r\n<ng-template #tableTemplate>\r\n  <table [ngStyle]=\"tableStyle\">\r\n    <tbody>\r\n      <tr>\r\n        <td [ngStyle]=\"tdStyle\">\r\n          <ng-container *ngTemplateOutlet=\"content\"></ng-container>\r\n        </td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</ng-template>\r\n<ng-template #divTemplate>\r\n  <div [ngStyle]=\"divStyle\">\r\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\r\n  </div>\r\n</ng-template>\r\n<ng-template #content><ng-content></ng-content></ng-template>", styles: [""] }]
        }], propDecorators: { width: [{
                type: Input
            }], height: [{
                type: Input
            }], orientation: [{
                type: Input
            }], horizontalAlignment: [{
                type: Input
            }], verticalAlignment: [{
                type: Input
            }] } });

class OrgItemConfig {
    constructor(config = {}) {
        this.id = null;
        this.parent = null;
        this.title = null;
        this.description = null;
        this.image = null;
        this.context = null;
        this.itemTitleColor = "#4169e1";
        this.minimizedItemShapeType = null;
        this.groupTitle = null;
        this.groupTitleColor = "#4169e1";
        this.isVisible = true;
        this.isActive = true;
        this.hasSelectorCheckbox = Enabled.Auto;
        this.hasButtons = Enabled.Auto;
        this.itemType = ItemType.Regular;
        this.adviserPlacementType = AdviserPlacementType.Auto;
        this.childrenPlacementType = ChildrenPlacementType.Auto;
        this.levelOffset = null;
        this.placeAssistantsAboveChildren = Enabled.Auto;
        this.placeAdvisersAboveChildren = Enabled.Auto;
        this.templateName = null;
        this.showCallout = Enabled.Auto;
        this.calloutTemplateName = null;
        this.label = null;
        this.showLabel = Enabled.Auto;
        this.labelSize = null;
        this.labelOrientation = TextOrientationType.Auto;
        Object.assign(this, config);
    }
}
;

class ItemComponent {
    constructor() {
        this.royalBlue = "#000080";
        this.itemTitleFirstFontColor = "#ffffff";
        this.itemTitleSecondFontColor = "#000080";
        this.itemConfig = new OrgItemConfig();
        this.backgroundColor = "#4169e1";
        this.color = "#ffffff";
    }
    ngOnChanges(changes) {
        this.backgroundColor = this.itemConfig.itemTitleColor || this.royalBlue;
        this.color = highestContrast(this.backgroundColor, this.itemTitleSecondFontColor, this.itemTitleFirstFontColor);
    }
}
ItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: ItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: ItemComponent, selector: "bp-item", inputs: { itemTitleFirstFontColor: "itemTitleFirstFontColor", itemTitleSecondFontColor: "itemTitleSecondFontColor", itemConfig: "itemConfig" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"item corner-all item-frame default-template\">\r\n  <div class=\"title-background item corner-all item-frame\" [ngStyle]=\"{backgroundColor}\">\r\n    <div class=\"item item-title\" [ngStyle]=\"{color}\">{{itemConfig.title}}</div>\r\n  </div>\r\n  <div class=\"photo-frame item\">\r\n    <img class=\"photo\" [src]=\"itemConfig.image\" [alt]=\"itemConfig.title\" />\r\n  </div>\r\n  <div class=\"item description\">{{itemConfig.description}}</div>\r\n</div>", styles: [".item{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.corner-all{border-radius:4px}.item-frame{border:1px solid #dddddd;background:#eeeeee;color:#333}.default-template{width:100%;height:100%;left:-1px;top:-1px}.item-title{text-overflow:ellipsis;-o-text-overflow:ellipsis;white-space:nowrap;text-align:left;font-size:14px;line-height:16px;color:#fff;padding:0;top:2px;left:2px;right:2px;height:16px}.title-background{top:2px;left:2px;right:2px;height:20px}.photo-frame{border:1px solid #cccccc;background:#f6f6f6;color:#1c94c4;top:26px;left:2px;width:50px;height:60px}.photo{height:60px;width:50px}.description{overflow:hidden;text-align:left;top:26px;left:56px;right:2px;bottom:2px;font-size:12px}\n"], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: ItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-item', template: "<div class=\"item corner-all item-frame default-template\">\r\n  <div class=\"title-background item corner-all item-frame\" [ngStyle]=\"{backgroundColor}\">\r\n    <div class=\"item item-title\" [ngStyle]=\"{color}\">{{itemConfig.title}}</div>\r\n  </div>\r\n  <div class=\"photo-frame item\">\r\n    <img class=\"photo\" [src]=\"itemConfig.image\" [alt]=\"itemConfig.title\" />\r\n  </div>\r\n  <div class=\"item description\">{{itemConfig.description}}</div>\r\n</div>", styles: [".item{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.corner-all{border-radius:4px}.item-frame{border:1px solid #dddddd;background:#eeeeee;color:#333}.default-template{width:100%;height:100%;left:-1px;top:-1px}.item-title{text-overflow:ellipsis;-o-text-overflow:ellipsis;white-space:nowrap;text-align:left;font-size:14px;line-height:16px;color:#fff;padding:0;top:2px;left:2px;right:2px;height:16px}.title-background{top:2px;left:2px;right:2px;height:20px}.photo-frame{border:1px solid #cccccc;background:#f6f6f6;color:#1c94c4;top:26px;left:2px;width:50px;height:60px}.photo{height:60px;width:50px}.description{overflow:hidden;text-align:left;top:26px;left:56px;right:2px;bottom:2px;font-size:12px}\n"] }]
        }], propDecorators: { itemTitleFirstFontColor: [{
                type: Input
            }], itemTitleSecondFontColor: [{
                type: Input
            }], itemConfig: [{
                type: Input
            }] } });
;

class CheckboxComponent {
    constructor() {
        this.id = null;
        this.label = "Selected";
        this.isSelected = false;
        this.onChange = () => null;
        this.borderWidth = "1px";
    }
}
CheckboxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: CheckboxComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CheckboxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: CheckboxComponent, selector: "bp-checkbox", inputs: { id: "id", label: "label", isSelected: "isSelected" }, ngImport: i0, template: `<div class="checkbox-div">
    <input type="checkbox" name="checkbox" class="checkbox-input" [checked]="isSelected" (change)="onChange" [attr.data-id]="id" />
      <span name="selectiontext" class="checkbox-span" [attr.data-id]="id" >
        {{label}}
      </span>
    </div>`, isInline: true, styles: [".checkbox-div{text-align:left}.checkbox-input{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0}.checkbox-span{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0 0 0 2px}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: CheckboxComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-checkbox', template: `<div class="checkbox-div">
    <input type="checkbox" name="checkbox" class="checkbox-input" [checked]="isSelected" (change)="onChange" [attr.data-id]="id" />
      <span name="selectiontext" class="checkbox-span" [attr.data-id]="id" >
        {{label}}
      </span>
    </div>`, styles: [".checkbox-div{text-align:left}.checkbox-input{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0}.checkbox-span{font-size:12px;line-height:12px;vertical-align:middle;margin:0;padding:0 0 0 2px}\n"] }]
        }], propDecorators: { id: [{
                type: Input
            }], label: [{
                type: Input
            }], isSelected: [{
                type: Input
            }] } });
;

class GroupTitleOptions {
    constructor(config = {}) {
        this.groupTitleFontSize = "12px";
        this.groupTitleFontFamily = "Arial";
        this.groupTitleFontWeight = "normal";
        this.groupTitleFontStyle = "normal";
        this.itemTitleSecondFontColor = "#000080";
        this.itemTitleFirstFontColor = "#ffffff";
        this.groupTitleOrientation = TextOrientationType.RotateRight;
        this.groupTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.groupTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.groupTitleColor = "#4169e1";
        Object.assign(this, config);
    }
}
class GroupTitleComponent {
    constructor() {
        this.options = new GroupTitleOptions();
        this.itemConfig = new OrgItemConfig();
        this.width = 0;
        this.height = 0;
        this.divStyle = null;
        this.label = "";
    }
    ngOnChanges(changes) {
        const backgroundColor = this.itemConfig.groupTitleColor || this.options.groupTitleColor;
        const color = highestContrast(backgroundColor, this.options.itemTitleSecondFontColor, this.options.itemTitleFirstFontColor);
        this.divStyle = {
            backgroundColor,
            color,
            fontSize: this.options.groupTitleFontSize,
            fontFamily: this.options.groupTitleFontFamily,
            fontWeight: this.options.groupTitleFontWeight,
            fontStyle: this.options.groupTitleFontStyle
        };
        this.label = (this.itemConfig.groupTitle || "").replace("\n", "<br/>");
    }
}
GroupTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: GroupTitleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
GroupTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: GroupTitleComponent, selector: "bp-group-title", inputs: { options: "options", itemConfig: "itemConfig", width: "width", height: "height" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"group-title\" [ngStyle]=\"divStyle\">\r\n  <rotated-text\r\n    [width]=\"width\"\r\n    [height]=\"height\"\r\n    [orientation]=\"options.groupTitleOrientation\"\r\n    [horizontalAlignment]=\"options.groupTitleHorizontalAlignment\"\r\n    [verticalAlignment]=\"options.groupTitleVerticalAlignment\"\r\n  >{{label}}</rotated-text>\r\n</div>\r\n", styles: [".group-title{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}\n"], components: [{ type: RotatedText, selector: "rotated-text", inputs: ["width", "height", "orientation", "horizontalAlignment", "verticalAlignment"] }], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: GroupTitleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-group-title', template: "<div class=\"group-title\" [ngStyle]=\"divStyle\">\r\n  <rotated-text\r\n    [width]=\"width\"\r\n    [height]=\"height\"\r\n    [orientation]=\"options.groupTitleOrientation\"\r\n    [horizontalAlignment]=\"options.groupTitleHorizontalAlignment\"\r\n    [verticalAlignment]=\"options.groupTitleVerticalAlignment\"\r\n  >{{label}}</rotated-text>\r\n</div>\r\n", styles: [".group-title{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}\n"] }]
        }], propDecorators: { options: [{
                type: Input
            }], itemConfig: [{
                type: Input
            }], width: [{
                type: Input
            }], height: [{
                type: Input
            }] } });
;

class TemplateConfig {
    constructor(config = {}) {
        this.name = null;
        this.isActive = true;
        this.itemSize = new Size(120, 100);
        this.itemBorderWidth = 1;
        this.itemTemplate = null;
        this.minimizedItemShapeType = null;
        this.minimizedItemSize = new Size(4, 4);
        this.minimizedItemCornerRadius = null;
        this.minimizedItemLineWidth = 1;
        this.minimizedItemBorderColor = null;
        this.minimizedItemLineType = LineType.Solid;
        this.minimizedItemFillColor = null;
        this.minimizedItemOpacity = 1;
        this.highlightPadding = new Thickness(2, 2, 2, 2);
        this.highlightBorderWidth = 1;
        this.highlightTemplate = null;
        this.cursorPadding = new Thickness(3, 3, 3, 3);
        this.cursorBorderWidth = 2;
        this.cursorTemplate = null;
        this.buttonsTemplate = null;
        Object.assign(this, config);
    }
}
;

class CursorComponent {
    constructor() {
        this.templateConfig = new TemplateConfig();
        this.borderWidth = "1px";
        this.width = "0px";
        this.height = "0px";
    }
    ngOnChanges(changes) {
        const { cursorPadding, itemSize, cursorBorderWidth } = this.templateConfig;
        this.width = (itemSize.width + cursorPadding.left + cursorPadding.right) + "px",
            this.height = (itemSize.height + cursorPadding.top + cursorPadding.bottom) + "px",
            this.borderWidth = cursorBorderWidth + "px";
    }
}
CursorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: CursorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CursorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: CursorComponent, selector: "bp-cursor", inputs: { templateConfig: "templateConfig" }, usesOnChanges: true, ngImport: i0, template: '<div class="cursor" [ngStyle]="{width, height, borderWidth}"></div>', isInline: true, styles: [".cursor{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:2px solid #fbd850;color:#eb8f00;width:100%;height:100%;left:-2px;top:-2px}\n"], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: CursorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-cursor', template: '<div class="cursor" [ngStyle]="{width, height, borderWidth}"></div>', styles: [".cursor{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:2px solid #fbd850;color:#eb8f00;width:100%;height:100%;left:-2px;top:-2px}\n"] }]
        }], propDecorators: { templateConfig: [{
                type: Input
            }] } });
;

class HighlightComponent {
    constructor() {
        this.templateConfig = new TemplateConfig();
        this.borderWidth = "1px";
    }
    ngOnChanges(changes) {
        const { highlightBorderWidth } = this.templateConfig;
        this.borderWidth = highlightBorderWidth + "px";
    }
}
HighlightComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: HighlightComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
HighlightComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: HighlightComponent, selector: "bp-highlight", inputs: { templateConfig: "templateConfig" }, usesOnChanges: true, ngImport: i0, template: '<div class="highlight" [ngStyle]="{borderWidth}"></div>', isInline: true, styles: [".highlight{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:-1px;top:-1px}\n"], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: HighlightComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-highlight', template: '<div class="highlight" [ngStyle]="{borderWidth}"></div>', styles: [".highlight{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:-1px;top:-1px}\n"] }]
        }], propDecorators: { templateConfig: [{
                type: Input
            }] } });
;

class DotHighlightComponent {
    constructor() {
        this.templateConfig = new TemplateConfig();
        this.divStyle = {};
    }
    ngOnChanges(changes) {
        const { minimizedItemCornerRadius, highlightPadding, highlightBorderWidth, minimizedItemSize } = this.templateConfig;
        let radius = 0;
        if (minimizedItemCornerRadius === null) {
            radius = Math.max(minimizedItemSize.width / 2, minimizedItemSize.height / 2) + highlightPadding.left;
        }
        else {
            radius = minimizedItemCornerRadius + highlightPadding.left;
        }
        this.divStyle = {
            borderWidth: highlightBorderWidth + "px",
            left: -highlightBorderWidth + "px",
            top: -highlightBorderWidth + "px",
            "-moz-border-radius": radius + "px",
            "-webkit-border-radius": radius + "px",
            "-khtml-border-radius": radius + "px",
            "border-radius": radius + "px"
        };
    }
}
DotHighlightComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: DotHighlightComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
DotHighlightComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: DotHighlightComponent, selector: "bp-dot-highlight", inputs: { templateConfig: "templateConfig" }, usesOnChanges: true, ngImport: i0, template: '<div class="dot-highlight" [ngStyle]="divStyle"></div>', isInline: true, styles: [".dot-highlight{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:0px;top:0px}\n"], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: DotHighlightComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-dot-highlight', template: '<div class="dot-highlight" [ngStyle]="divStyle"></div>', styles: [".dot-highlight{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border:1px solid #fbcb09;background:#fdf5ce;color:#c77405;width:100%;height:100%;left:0px;top:0px}\n"] }]
        }], propDecorators: { templateConfig: [{
                type: Input
            }] } });
;

class LevelAnnotationConfig {
    constructor(config = {}) {
        this.annotationType = AnnotationType.Level;
        this.levels = [];
        this.title = null;
        this.titleFontColor = null;
        this.titleColor = null;
        this.offset = new Thickness(0, 0, 0, 0);
        this.lineWidth = new Thickness(0, 0, 0, 0);
        this.opacity = 1;
        this.borderColor = null;
        this.fillColor = "#D4D4D4";
        this.lineType = LineType.Solid;
        Object.assign(this, config);
    }
}
;

class LevelTitleOptions {
    constructor(config = {}) {
        this.levelTitleFontSize = "12px";
        this.levelTitleFontFamily = "Arial";
        this.levelTitleFontWeight = "normal";
        this.levelTitleFontStyle = "normal";
        this.levelTitleFontColor = "#ffffff";
        this.levelTitleOrientation = TextOrientationType.Auto;
        this.levelTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.levelTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.levelTitleColor = "#4169e1";
        Object.assign(this, config);
    }
}
class LevelTitleComponent {
    constructor() {
        this.options = new LevelTitleOptions();
        this.annotationConfig = new LevelAnnotationConfig();
        this.width = 0;
        this.height = 0;
        this.divStyle = null;
        this.label = "";
    }
    ngOnChanges(changes) {
        const backgroundColor = this.annotationConfig.titleColor || this.options.levelTitleColor;
        const color = this.annotationConfig.titleFontColor || this.options.levelTitleFontColor;
        this.divStyle = {
            backgroundColor,
            color,
            fontSize: this.options.levelTitleFontSize,
            fontFamily: this.options.levelTitleFontFamily,
            fontWeight: this.options.levelTitleFontWeight,
            fontStyle: this.options.levelTitleFontStyle
        };
        this.label = (this.annotationConfig.title || "").replace("\n", "<br/>");
    }
}
LevelTitleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: LevelTitleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LevelTitleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: LevelTitleComponent, selector: "bp-level-title", inputs: { options: "options", annotationConfig: "annotationConfig", width: "width", height: "height" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"level-title\" [ngStyle]=\"divStyle\">\r\n  <rotated-text\r\n    [width]=\"width\"\r\n    [height]=\"height\"\r\n    [orientation]=\"options.levelTitleOrientation\"\r\n    [horizontalAlignment]=\"options.levelTitleHorizontalAlignment\"\r\n    [verticalAlignment]=\"options.levelTitleVerticalAlignment\"\r\n  >{{label}}</rotated-text>\r\n</div>", styles: [".level-title{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}\n"], components: [{ type: RotatedText, selector: "rotated-text", inputs: ["width", "height", "orientation", "horizontalAlignment", "verticalAlignment"] }], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: LevelTitleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-level-title', template: "<div class=\"level-title\" [ngStyle]=\"divStyle\">\r\n  <rotated-text\r\n    [width]=\"width\"\r\n    [height]=\"height\"\r\n    [orientation]=\"options.levelTitleOrientation\"\r\n    [horizontalAlignment]=\"options.levelTitleHorizontalAlignment\"\r\n    [verticalAlignment]=\"options.levelTitleVerticalAlignment\"\r\n  >{{label}}</rotated-text>\r\n</div>", styles: [".level-title{position:absolute;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;border-radius:4px;background:royalblue;border-width:0;color:#fff;padding:0;width:100%;height:100%;left:-1px;top:-1px}\n"] }]
        }], propDecorators: { options: [{
                type: Input
            }], annotationConfig: [{
                type: Input
            }], width: [{
                type: Input
            }], height: [{
                type: Input
            }] } });
;

function getBorderStyle(lineType) {
    var result = null;
    switch (lineType) {
        case LineType.Dotted:
            result = "dotted";
            break;
        case LineType.Dashed:
            result = "dashed";
            break;
        default:
            result = "solid";
            break;
    }
    return result;
}
class LevelBackgroundComponent {
    constructor() {
        this.annotationConfig = new LevelAnnotationConfig();
        this.divStyle = {};
    }
    ngOnChanges(changes) {
        this.divStyle = {
            opacity: this.annotationConfig.opacity,
            borderColor: this.annotationConfig.borderColor,
            backgroundColor: this.annotationConfig.fillColor,
            borderWidth: this.annotationConfig.lineWidth.toString(),
            borderStyle: getBorderStyle(this.annotationConfig.lineType),
        };
    }
}
LevelBackgroundComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: LevelBackgroundComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LevelBackgroundComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: LevelBackgroundComponent, selector: "bp-level-background", inputs: { annotationConfig: "annotationConfig" }, usesOnChanges: true, ngImport: i0, template: '<div class="level-background" [ngStyle]="divStyle"></div>', isInline: true, styles: [".level-background{position:absolute;width:100%;height:100%}\n"], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: LevelBackgroundComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bp-level-background', template: '<div class="level-background" [ngStyle]="divStyle"></div>', styles: [".level-background{position:absolute;width:100%;height:100%}\n"] }]
        }], propDecorators: { annotationConfig: [{
                type: Input
            }] } });
;

class LayoutOptions {
    constructor(config = {}) {
        this.autoSize = false;
        this.controlSize = new Size();
        this.scale = 1;
        this.frameMousePanelRect = new Rect();
        this.framePlaceholderSize = new Size();
        this.titlesMousePanelRect = new Rect();
        this.titlesPlaceholderSize = new Size();
        this.scrollPanelRect = new Rect();
        this.mousePanelSize = new Size();
        this.placeholderSize = new Size();
        Object.assign(this, config);
    }
}
class BaseDiagramState {
    constructor() {
        this.viewportSize = new Size(0, 0);
        this.contentPosition = new Point(0, 0);
        this.centerOnCursor = true;
        this.highlightItem = null;
        this.cursorItem = null;
        this.selectedItems = [];
    }
}
;
class BaseDiagramComponent {
    constructor(host, zone, taskManagerFactory) {
        this.host = host;
        this.zone = zone;
        this.centerOnCursor = true;
        this.state = new BaseDiagramState();
        this.layoutOptions = new LayoutOptions();
        this.timer = null;
        this.templatesHash = {};
        /* Component template properties */
        this.placeholder = null;
        this.framePlaceholder = null;
        this.titlesPlaceholder = null;
        this.calloutPlaceholder = null;
        this.controlPanelStyle = {};
        this.frameMousePanelStyle = {};
        this.framePlaceholderStyle = {};
        this.titlesMousePanelStyle = {};
        this.titlesPlaceholderStyle = {};
        this.scrollPanelStyle = {};
        this.placeholderOffset = undefined;
        this.mousePanelStyle = {};
        this.placeholderStyle = {};
        this.calloutPlaceholderStyle = {};
        this.taskManagerFactory = taskManagerFactory;
        this.graphics = new Graphics(new Size(0, 0));
        var templates = {
            AnnotationLabelTemplate,
            ButtonsTemplate,
            CheckBoxTemplate,
            CursorTemplate,
            DotHighlightTemplate,
            GroupTitleTemplate,
            HighlightTemplate,
            ItemTemplate,
            UserTemplate,
            CustomRenderTemplate,
            LabelAnnotationTemplate,
            LevelTitleTemplate,
            LevelBackgroundTemplate
        };
        this.tasks = taskManagerFactory.factory(this.getOptions.bind(this), this.getGraphics.bind(this), this.getLayout.bind(this), this.setLayout.bind(this), templates);
        this.layoutOptions = new LayoutOptions();
    }
    ngAfterViewInit() {
        var onSizeChanged = this.onSizeChanged.bind(this);
        this.observer = new ResizeObserver(() => this.zone.run(() => onSizeChanged()));
        this.observer.observe(this.controlPanelRef.nativeElement);
        this.fixPixelAlignment();
    }
    _onHighlightChanging(event, itemId, newItemId) { }
    ;
    _onHighlightChanged(eventArgs) { }
    ;
    _onCursorChanging(event, itemId, newItemId) { }
    ;
    _onCursorChanged(eventArgs) { }
    ;
    _onSelectionChanging(event, selectedItems, newSelectedItems) { }
    ;
    _onSelectionChanged(eventArgs) { }
    ;
    onItemRender(data) {
        const { templateName } = data;
        const template = this.templatesHash[templateName];
        return template.itemTemplate;
    }
    onHighlightRender(data) {
        const { templateName } = data;
        const template = this.templatesHash[templateName];
        return template.highlightTemplate;
    }
    onCursorRender(data) {
        const { templateName } = data;
        const template = this.templatesHash[templateName];
        return template.cursorTemplate;
    }
    getOptions() {
        const { config } = this.state;
        const templates = config.templates || [];
        this.templatesHash = {};
        templates.forEach(template => {
            this.templatesHash[template.name] = template;
        });
        const effectiveTemplates = templates.map(template => {
            const { buttonsTemplate } = template;
            return {
                ...template,
                onButtonsRender: !buttonsTemplate ? null : () => buttonsTemplate
            };
        });
        const { highlightItem, cursorItem, selectedItems } = this.state;
        return {
            ...config,
            templates: effectiveTemplates,
            highlightItem,
            cursorItem,
            selectedItems,
            onItemRender: this.onItemRender.bind(this),
            onCursorRender: this.onCursorRender.bind(this),
            onHighlightRender: this.onHighlightRender.bind(this),
            onGroupTitleRender: !config.groupTitleTemplate ? null : () => config.groupTitleTemplate,
            onLevelBackgroundRender: !config.levelBackgroundTemplate ? null : () => config.levelBackgroundTemplate,
            onLevelTitleRender: !config.levelTitleTemplate ? null : () => config.levelTitleTemplate,
            onButtonsRender: !config.buttonsTemplate ? null : () => config.buttonsTemplate
        };
    }
    getGraphics() {
        return this.graphics;
    }
    getLayout() {
        var centerOnCursor = this.state.centerOnCursor;
        var viewportSize = this.state.viewportSize;
        var contentPosition = this.state.contentPosition;
        // var { centerOnCursor, viewportSize, contentPosition } = this.state;
        return {
            forceCenterOnCursor: centerOnCursor,
            scrollPanelSize: new Size(viewportSize.width, viewportSize.height),
            placeholderOffset: new Point(contentPosition.x, contentPosition.y)
        };
    }
    setLayout(layoutOptions) {
        const { autoSize, // resize control if true
        controlSize, // Sets control Size in auto scale mode
        scale, // scale is needed for scale transform CSS creation
        frameMousePanelRect, framePlaceholderSize, // the frame content size before CSS Scale Transform applied
        titlesMousePanelRect, titlesPlaceholderSize, // Titles size before CSS Scale Transform applied
        scrollPanelRect, mousePanelSize, // Content mouse panel size
        placeholderSize // Content size before CSS Scale Transform applied
         } = layoutOptions;
        this.layoutOptions = new LayoutOptions({
            autoSize,
            controlSize: new Size(controlSize.width, controlSize.height),
            scale,
            frameMousePanelRect: new Rect(frameMousePanelRect.x, frameMousePanelRect.y, frameMousePanelRect.width, frameMousePanelRect.height),
            framePlaceholderSize: new Size(framePlaceholderSize.width, framePlaceholderSize.height),
            titlesMousePanelRect: new Rect(titlesMousePanelRect.x, titlesMousePanelRect.y, titlesMousePanelRect.width, titlesMousePanelRect.height),
            titlesPlaceholderSize: new Size(titlesPlaceholderSize.width, titlesPlaceholderSize.height),
            scrollPanelRect: new Rect(scrollPanelRect.x, scrollPanelRect.y, scrollPanelRect.width, scrollPanelRect.height),
            mousePanelSize: new Size(mousePanelSize.width, mousePanelSize.height),
            placeholderSize: new Size(placeholderSize.width, placeholderSize.height)
        });
    }
    fixPixelAlignment() {
        const { nativeElement } = this.controlPanelRef;
        var pixelAlignmentFix = getFixOfPixelAlignment(nativeElement);
        nativeElement.style.marginLeft = pixelAlignmentFix.width + "px";
        nativeElement.style.marginTop = pixelAlignmentFix.height + "px";
    }
    onSizeChanged() {
        const { width, height } = getInnerSize(this.controlPanelRef.nativeElement);
        this.setState({
            viewportSize: new Size(width, height),
            centerOnCursor: true
        });
    }
    onScroll(event) {
        if (this.timer == null) {
            this.timer = window.setTimeout(this.onRefreshViewport.bind(this), 100);
        }
    }
    onRefreshViewport() {
        window.clearTimeout(this.timer);
        this.timer = null;
        const { scrollTop, scrollLeft } = this.scrollPanelRef.nativeElement;
        this.setState({
            contentPosition: new Point(Math.floor(scrollLeft), Math.floor(scrollTop)),
            centerOnCursor: false
        });
    }
    onFrameMouseMove(event) {
        const placeholderOffset = getElementOffset(this.frameMousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, projectItemsToFrameTask = this.tasks.getTask("ProjectItemsToFrameTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask");
        if (highlightItemOptionTask.hasHighlightEnabled()) {
            const itemId = projectItemsToFrameTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
            this.setHighlightItem(event, itemId);
        }
    }
    onFrameClick(event) {
        const placeholderOffset = getElementOffset(this.frameMousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, projectItemsToFrameTask = this.tasks.getTask("ProjectItemsToFrameTask"), cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"), newCursorItemId = projectItemsToFrameTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
        if (newCursorItemId !== null) {
            if (cursorItemOptionTask.hasCursorEnabled()) {
                this.setCursorItem(event, newCursorItemId);
                this.controlPanelRef.nativeElement.focus();
            }
        }
    }
    onMouseMove(event) {
        const placeholderOffset = getElementOffset(this.mousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, createTransformTask = this.tasks.getTask("CreateTransformTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask");
        if (highlightItemOptionTask.hasHighlightEnabled()) {
            const itemId = createTransformTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
            this.setHighlightItem(event, itemId);
        }
    }
    getEventArgs(oldTreeItemId, newTreeItemId, name = null) {
        var result = {}, combinedContextsTask = this.tasks.getTask("CombinedContextsTask"), alignDiagramTask = this.tasks.getTask("AlignDiagramTask"), oldItemConfig = combinedContextsTask.getConfig(oldTreeItemId), newItemConfig = combinedContextsTask.getConfig(newTreeItemId), itemPosition, offset, panelOffset;
        if (oldItemConfig && oldItemConfig.id != null) {
            result.oldContext = oldItemConfig;
        }
        if (newItemConfig && newItemConfig.id != null) {
            result.context = newItemConfig;
            if (newItemConfig.parent !== null) {
                result.parentItem = combinedContextsTask.getConfig(newItemConfig.parent);
            }
            panelOffset = getElementOffset(this.mousePanelRef.nativeElement);
            offset = getElementOffset(this.scrollPanelRef.nativeElement);
            itemPosition = alignDiagramTask.getItemPosition(newTreeItemId);
            result.position = new Rect(itemPosition.actualPosition)
                .translate(panelOffset.left, panelOffset.top)
                .translate(-offset.left, -offset.top);
        }
        if (name != null) {
            result.name = name;
        }
        return result;
    }
    setHighlightItem(event, newHighlightItemId) {
        let eventArgs, cancel = false;
        const { highlightItem } = this.state;
        if (newHighlightItemId !== highlightItem) {
            eventArgs = this._onHighlightChanging(event, highlightItem, newHighlightItemId);
            if (!eventArgs.cancel) {
                this.setState({
                    highlightItem: newHighlightItemId
                });
                this._onHighlightChanged(eventArgs);
            }
        }
    }
    setCursorItem(event, newCursorItemId) {
        let eventArgs, cancel = false;
        const { cursorItem } = this.state;
        if (newCursorItemId !== cursorItem) {
            eventArgs = this._onCursorChanging(event, cursorItem, newCursorItemId);
            if (!eventArgs.cancel) {
                this.setState({
                    cursorItem: newCursorItemId,
                    centerOnCursor: true
                });
                this._onCursorChanged(eventArgs);
            }
        }
    }
    onClick(event) {
        var placeholderOffset = getElementOffset(this.mousePanelRef.nativeElement), x = event.pageX - placeholderOffset.left, y = event.pageY - placeholderOffset.top, createTransformTask = this.tasks.getTask("CreateTransformTask"), cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"), newCursorItemId = createTransformTask.getTreeItemForMousePosition(x, y, highlightItemOptionTask.getGravityRadius());
        var target = event.target;
        if (newCursorItemId !== null) {
            if (target.getAttribute("name") === "checkbox" || target.getAttribute("name") === "selectiontext") { //ignore jslint
            }
            else {
                if (cursorItemOptionTask.hasCursorEnabled()) {
                    this.setCursorItem(event, newCursorItemId);
                    this.controlPanelRef.nativeElement.focus();
                }
            }
        }
    }
    onCheckboxChange(event) {
        let { selectedItems } = this.state;
        let newSelectedItems = [];
        const target = event.target;
        var itemId = target.getAttribute("data-id");
        const checked = target.checked;
        let cancel = false;
        if (itemId != null) {
            if (checked) {
                newSelectedItems = [...selectedItems, itemId];
            }
            else {
                // eslint-disable-next-line
                newSelectedItems = selectedItems.filter(id => id != itemId); // User type may not mach string value in data attribute
            }
            var eventArgs = this._onSelectionChanging(event, selectedItems, newSelectedItems);
            if (!eventArgs.cancel) {
                this.setState({
                    selectedItems: newSelectedItems
                });
                this._onSelectionChanged(eventArgs);
            }
        }
    }
    onKeyDown(event) {
        var highlightItemTask = this.tasks.getTask("HighlightItemTask"), highlightItemOptionTask = this.tasks.getTask("HighlightItemOptionTask"), cursorItemTask = this.tasks.getTask("CursorItemTask"), cursorItemOptionTask = this.tasks.getTask("CursorItemOptionTask"), alignDiagramTask = this.tasks.getTask('AlignDiagramTask'), createTransformTask = this.tasks.getTask('CreateTransformTask'), transform = createTransformTask.getTransform(), navigationItem = null, newNavigationItem, direction = null, accepted;
        if (highlightItemOptionTask.hasHighlightEnabled() && cursorItemOptionTask.hasCursorEnabled()) {
            navigationItem = highlightItemTask.getHighlightTreeItem();
            if (navigationItem === null) {
                navigationItem = cursorItemTask.getCursorTreeItem();
            }
        }
        else if (highlightItemOptionTask.hasHighlightEnabled()) {
            navigationItem = highlightItemTask.getHighlightTreeItem();
        }
        else if (cursorItemOptionTask.hasCursorEnabled()) {
            navigationItem = cursorItemTask.getCursorTreeItem();
        }
        if (navigationItem != null) {
            switch (event.which) {
                case 13: /*Enter*/
                    if (cursorItemOptionTask.hasCursorEnabled()) {
                        this.setCursorItem(event, navigationItem);
                        event.preventDefault();
                        this.controlPanelRef.nativeElement.focus();
                    }
                    break;
                case 40: /*Down*/
                    direction = OrientationType.Bottom;
                    break;
                case 38: /*Up*/
                    direction = OrientationType.Top;
                    break;
                case 37: /*Left*/
                    direction = OrientationType.Left;
                    break;
                case 39: /*Right*/
                    direction = OrientationType.Right;
                    break;
                default:
                    break;
            }
            if (direction != null) {
                accepted = false;
                while (!accepted) {
                    accepted = true;
                    direction = transform.getOrientation(direction);
                    newNavigationItem = alignDiagramTask.getNextItem(navigationItem, direction);
                    if (newNavigationItem != null) {
                        event.preventDefault();
                        if (highlightItemOptionTask.hasHighlightEnabled()) {
                            this.setHighlightItem(event, newNavigationItem);
                        }
                        else if (cursorItemOptionTask.hasCursorEnabled()) {
                            this.setCursorItem(event, newNavigationItem);
                        }
                    }
                }
                this.controlPanelRef.nativeElement.focus();
            }
        }
    }
    setState(newState = {}) {
        this.state = {
            ...this.state,
            ...newState
        };
        this.render();
    }
    ngOnInit() {
        this.render();
    }
    render() {
        this.tasks.process('OptionsTask', null, false);
        const { placeholder, calloutplaceholder: calloutPlaceholder, frameplaceholder: framePlaceholder, titlesplaceholder: titlesPlaceholder } = this.graphics.placeholders;
        this.placeholder = placeholder;
        this.titlesPlaceholder = titlesPlaceholder;
        this.framePlaceholder = framePlaceholder;
        this.calloutPlaceholder = calloutPlaceholder;
        const { autoSize, // resize control if true
        controlSize, // Sets control Size in auto scale mode
        scale, // scale is needed for scale transform CSS creation
        frameMousePanelRect, titlesMousePanelRect, scrollPanelRect, mousePanelSize // Content mouse panel size
         } = this.layoutOptions;
        var scaleText = "scale(" + scale + "," + scale + ")";
        this.controlPanelStyle = autoSize ? controlSize.getCSS() : {};
        this.frameMousePanelStyle = frameMousePanelRect.getCSS();
        if (framePlaceholder) {
            this.framePlaceholderStyle = {
                ...(framePlaceholder.rect.getCSS()),
                "transform": scaleText,
                "msTransform": scaleText,
                "WebkitTransform": scaleText,
                "OTransform": scaleText,
                "MozTransform": scaleText
            };
        }
        this.titlesMousePanelStyle = {
            ...titlesMousePanelRect.getCSS()
        };
        if (titlesPlaceholder) {
            this.titlesPlaceholderStyle = {
                ...(titlesPlaceholder.rect.getCSS()),
                "transformOrigin": "0 0",
                "transform": scaleText,
                "msTransform": scaleText,
                "WebkitTransform": scaleText,
                "OTransform": scaleText,
                "MozTransform": scaleText
            };
        }
        this.scrollPanelStyle = {
            ...(scrollPanelRect.getCSS()),
            border: (scrollPanelRect.x > 0 ? "1px dotted #dddddd" : "")
        };
        this.mousePanelStyle = {
            ...(mousePanelSize.getCSS())
        };
        this.placeholderStyle = {
            ...(placeholder.rect.getCSS()),
            "transform": scaleText,
            "msTransform": scaleText,
            "WebkitTransform": scaleText,
            "OTransform": scaleText,
            "MozTransform": scaleText
        };
        if (calloutPlaceholder) {
            this.calloutPlaceholderStyle = {
                left: calloutPlaceholder.rect.x + "px",
                top: calloutPlaceholder.rect.y + "px"
            };
        }
        const { centerOnCursor } = this.state;
        if (centerOnCursor) {
            const centerOnCursorTask = this.tasks.getTask("CenterOnCursorTask");
            this.placeholderOffset = centerOnCursorTask.getPlaceholderOffset();
        }
    }
    ngOnDestroy() {
        // destroy timer
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        // destroy observer
        this.observer.disconnect();
    }
}
BaseDiagramComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BaseDiagramComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: TaskManagerFactory }], target: i0.ɵɵFactoryTarget.Component });
BaseDiagramComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: BaseDiagramComponent, selector: "ng-component", inputs: { centerOnCursor: "centerOnCursor" }, viewQueries: [{ propertyName: "frameMousePanelRef", first: true, predicate: ["frameMousePanelRef"], descendants: true }, { propertyName: "framePlaceholderRef", first: true, predicate: ["framePlaceholderRef"], descendants: true }, { propertyName: "titlesMousePanelRef", first: true, predicate: ["titlesMousePanelRef"], descendants: true }, { propertyName: "titlesPlaceholderRef", first: true, predicate: ["titlesPlaceholderRef"], descendants: true }, { propertyName: "scrollPanelRef", first: true, predicate: ["scrollPanelRef"], descendants: true }, { propertyName: "mousePanelRef", first: true, predicate: ["mousePanelRef"], descendants: true }, { propertyName: "placeholderRef", first: true, predicate: ["placeholderRef"], descendants: true }, { propertyName: "calloutPlaceholderRef", first: true, predicate: ["calloutPlaceholderRef"], descendants: true }, { propertyName: "controlPanelRef", first: true, predicate: ["controlPanelRef"], descendants: true }], ngImport: i0, template: "<!-- root control panel -->\n<div #controlPanelRef\n  class=\"control-panel\"\n  [ngStyle]=\"controlPanelStyle\"\n  (keydown)=\"onKeyDown($event)\"\n  tabIndex=\"0\"\n>\n  <div *ngIf=\"framePlaceholder\"\n    #frameMousePanelRef\n    class=\"frame-mouse-panel\"\n    [ngStyle]=\"frameMousePanelStyle\"\n    (click)=\"onFrameClick($event)\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n  >\n    <div #framePlaceholderRef\n      class=\"frame-placeholder\" \n      [ngStyle]=\"framePlaceholderStyle\"\n    >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: framePlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div *ngIf=\"titlesPlaceholder\"\n    #titlesMousePanelRef\n    class=\"titles-mouse-panel\"\n    [ngStyle]=\"titlesMousePanelStyle\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n    (click)=\"onFrameClick($event)\"\n  >\n    <div #titlesPlaceholderRef\n      [ngStyle]=\"titlesPlaceholderStyle\"\n      class=\"titles-placeholder\"\n     >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: titlesPlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div\n    #scrollPanelRef\n    class=\"scroll-panel\"\n    [ngStyle]=\"scrollPanelStyle\"\n    (scroll)=\"onScroll($event)\"\n    [scrollLeft]=\"placeholderOffset ? placeholderOffset.x : undefined\"\n    [scrollTop]=\"placeholderOffset ? placeholderOffset.y : undefined\"\n  >\n    <div #mousePanelRef\n      class=\"mouse-panel\"\n      [ngStyle]=\"mousePanelStyle\"\n      (mousemove)=\"onMouseMove($event)\"\n      (click)=\"onClick($event)\"\n      (change)=\"onCheckboxChange($event)\"\n    >\n      <div #placeholderRef\n        class=\"placeholder\"\n        [ngStyle]=\"placeholderStyle\"\n      >\n        <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: placeholder}\"></ng-container>\n        <div *ngIf=\"calloutPlaceholder\"\n          #calloutPlaceholderRef\n          class=\"callout-placeholder\"\n          [ngStyle]=\"calloutPlaceholderStyle\"\n        >\n          <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: calloutPlaceholder}\"></ng-container>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!--Templates: -->\n<ng-template #layerTemplate let-placeholder>\n  <div *ngFor=\"let layer of placeholder.layers\" class=\"layer\">\n    <ng-container *ngIf=\"layer\">\n      <div *ngFor=\"let label of layer.labels\" class=\"label\" [ngStyle]= \"label.style\">\n        <rotated-text\n          [width]=\"label.width\"\n          [height]=\"label.height\"\n          [orientation]=\"label.orientation\"\n          [horizontalAlignment]=\"label.horizontalAlignment\"\n          [verticalAlignment]=\"label.verticalAlignment\"\n        >{{label.label}}</rotated-text>\n      </div>\n      <svg \n        *ngIf=\"layer.polylines.length > 0\"\n        attr.height.px=\"{{placeholder.size.height}}\"\n        attr.width.px=\"{{placeholder.size.width}}\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n        [ngStyle]=\"{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}\"\n      >\n        <path *ngFor=\"let path of layer.polylines\" [attr.d]=\"path.data\" [ngStyle]=\"path.style\"></path>\n      </svg>\n      <div *ngFor=\"let item of layer.items;\" class=\"template\" [ngStyle]=\"item.style\">\n        <ng-container [ngSwitch]=\"item.templateType\">\n          <ng-container *ngSwitchCase=\"'itemTemplate'\">\n            <bp-item [itemConfig]=\"item.context.context\" [itemTitleFirstFontColor]=\"item.context.itemTitleFirstFontColor\" [itemTitleSecondFontColor]=\"item.context.itemTitleSecondFontColor\"></bp-item>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'checkboxTemplate'\">\n            <bp-checkbox [id]=\"item.context.id\" [isSelected]=\"item.context.isSelected\" [label]=\"item.context.selectCheckBoxLabel\"></bp-checkbox>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'groupTitleTemplate'\">\n            <bp-group-title [options]=\"item.context\" [itemConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-group-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'cursorTemplate'\">\n            <bp-cursor [templateConfig]=\"item.context.templateConfig\"></bp-cursor>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'highlightTemplate'\">\n            <bp-highlight [templateConfig]=\"item.context.templateConfig\"></bp-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'dotHighlightTemplate'\">\n            <bp-dot-highlight [templateConfig]=\"item.context.templateConfig\"></bp-dot-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelTitleTemplate'\">\n            <bp-level-title [options]=\"item.context\" [annotationConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-level-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelBackgroundTemplate'\">\n            <bp-level-background [annotationConfig]=\"item.context.context\"></bp-level-background>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'labelAnnotationTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.title}}</div>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'annotationLabelTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.label}}</div>\n          </ng-container>\n          <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"item.templateRef; context: item.context\"></ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n</ng-template>\n", styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"], components: [{ type: RotatedText, selector: "rotated-text", inputs: ["width", "height", "orientation", "horizontalAlignment", "verticalAlignment"] }, { type: ItemComponent, selector: "bp-item", inputs: ["itemTitleFirstFontColor", "itemTitleSecondFontColor", "itemConfig"] }, { type: CheckboxComponent, selector: "bp-checkbox", inputs: ["id", "label", "isSelected"] }, { type: GroupTitleComponent, selector: "bp-group-title", inputs: ["options", "itemConfig", "width", "height"] }, { type: CursorComponent, selector: "bp-cursor", inputs: ["templateConfig"] }, { type: HighlightComponent, selector: "bp-highlight", inputs: ["templateConfig"] }, { type: DotHighlightComponent, selector: "bp-dot-highlight", inputs: ["templateConfig"] }, { type: LevelTitleComponent, selector: "bp-level-title", inputs: ["options", "annotationConfig", "width", "height"] }, { type: LevelBackgroundComponent, selector: "bp-level-background", inputs: ["annotationConfig"] }], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i10.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i10.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i10.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i10.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i10.NgSwitchDefault, selector: "[ngSwitchDefault]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BaseDiagramComponent, decorators: [{
            type: Component,
            args: [{ template: "<!-- root control panel -->\n<div #controlPanelRef\n  class=\"control-panel\"\n  [ngStyle]=\"controlPanelStyle\"\n  (keydown)=\"onKeyDown($event)\"\n  tabIndex=\"0\"\n>\n  <div *ngIf=\"framePlaceholder\"\n    #frameMousePanelRef\n    class=\"frame-mouse-panel\"\n    [ngStyle]=\"frameMousePanelStyle\"\n    (click)=\"onFrameClick($event)\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n  >\n    <div #framePlaceholderRef\n      class=\"frame-placeholder\" \n      [ngStyle]=\"framePlaceholderStyle\"\n    >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: framePlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div *ngIf=\"titlesPlaceholder\"\n    #titlesMousePanelRef\n    class=\"titles-mouse-panel\"\n    [ngStyle]=\"titlesMousePanelStyle\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n    (click)=\"onFrameClick($event)\"\n  >\n    <div #titlesPlaceholderRef\n      [ngStyle]=\"titlesPlaceholderStyle\"\n      class=\"titles-placeholder\"\n     >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: titlesPlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div\n    #scrollPanelRef\n    class=\"scroll-panel\"\n    [ngStyle]=\"scrollPanelStyle\"\n    (scroll)=\"onScroll($event)\"\n    [scrollLeft]=\"placeholderOffset ? placeholderOffset.x : undefined\"\n    [scrollTop]=\"placeholderOffset ? placeholderOffset.y : undefined\"\n  >\n    <div #mousePanelRef\n      class=\"mouse-panel\"\n      [ngStyle]=\"mousePanelStyle\"\n      (mousemove)=\"onMouseMove($event)\"\n      (click)=\"onClick($event)\"\n      (change)=\"onCheckboxChange($event)\"\n    >\n      <div #placeholderRef\n        class=\"placeholder\"\n        [ngStyle]=\"placeholderStyle\"\n      >\n        <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: placeholder}\"></ng-container>\n        <div *ngIf=\"calloutPlaceholder\"\n          #calloutPlaceholderRef\n          class=\"callout-placeholder\"\n          [ngStyle]=\"calloutPlaceholderStyle\"\n        >\n          <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: calloutPlaceholder}\"></ng-container>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!--Templates: -->\n<ng-template #layerTemplate let-placeholder>\n  <div *ngFor=\"let layer of placeholder.layers\" class=\"layer\">\n    <ng-container *ngIf=\"layer\">\n      <div *ngFor=\"let label of layer.labels\" class=\"label\" [ngStyle]= \"label.style\">\n        <rotated-text\n          [width]=\"label.width\"\n          [height]=\"label.height\"\n          [orientation]=\"label.orientation\"\n          [horizontalAlignment]=\"label.horizontalAlignment\"\n          [verticalAlignment]=\"label.verticalAlignment\"\n        >{{label.label}}</rotated-text>\n      </div>\n      <svg \n        *ngIf=\"layer.polylines.length > 0\"\n        attr.height.px=\"{{placeholder.size.height}}\"\n        attr.width.px=\"{{placeholder.size.width}}\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n        [ngStyle]=\"{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}\"\n      >\n        <path *ngFor=\"let path of layer.polylines\" [attr.d]=\"path.data\" [ngStyle]=\"path.style\"></path>\n      </svg>\n      <div *ngFor=\"let item of layer.items;\" class=\"template\" [ngStyle]=\"item.style\">\n        <ng-container [ngSwitch]=\"item.templateType\">\n          <ng-container *ngSwitchCase=\"'itemTemplate'\">\n            <bp-item [itemConfig]=\"item.context.context\" [itemTitleFirstFontColor]=\"item.context.itemTitleFirstFontColor\" [itemTitleSecondFontColor]=\"item.context.itemTitleSecondFontColor\"></bp-item>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'checkboxTemplate'\">\n            <bp-checkbox [id]=\"item.context.id\" [isSelected]=\"item.context.isSelected\" [label]=\"item.context.selectCheckBoxLabel\"></bp-checkbox>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'groupTitleTemplate'\">\n            <bp-group-title [options]=\"item.context\" [itemConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-group-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'cursorTemplate'\">\n            <bp-cursor [templateConfig]=\"item.context.templateConfig\"></bp-cursor>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'highlightTemplate'\">\n            <bp-highlight [templateConfig]=\"item.context.templateConfig\"></bp-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'dotHighlightTemplate'\">\n            <bp-dot-highlight [templateConfig]=\"item.context.templateConfig\"></bp-dot-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelTitleTemplate'\">\n            <bp-level-title [options]=\"item.context\" [annotationConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-level-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelBackgroundTemplate'\">\n            <bp-level-background [annotationConfig]=\"item.context.context\"></bp-level-background>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'labelAnnotationTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.title}}</div>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'annotationLabelTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.label}}</div>\n          </ng-container>\n          <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"item.templateRef; context: item.context\"></ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n</ng-template>\n", styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: TaskManagerFactory }]; }, propDecorators: { frameMousePanelRef: [{
                type: ViewChild,
                args: ['frameMousePanelRef']
            }], framePlaceholderRef: [{
                type: ViewChild,
                args: ['framePlaceholderRef']
            }], titlesMousePanelRef: [{
                type: ViewChild,
                args: ['titlesMousePanelRef']
            }], titlesPlaceholderRef: [{
                type: ViewChild,
                args: ['titlesPlaceholderRef']
            }], scrollPanelRef: [{
                type: ViewChild,
                args: ['scrollPanelRef']
            }], mousePanelRef: [{
                type: ViewChild,
                args: ['mousePanelRef']
            }], placeholderRef: [{
                type: ViewChild,
                args: ['placeholderRef']
            }], calloutPlaceholderRef: [{
                type: ViewChild,
                args: ['calloutPlaceholderRef']
            }], controlPanelRef: [{
                type: ViewChild,
                args: ['controlPanelRef']
            }], centerOnCursor: [{
                type: Input
            }] } });

class FamEventArgs {
    constructor(config = {}) {
        this.oldContext = null;
        this.context = null;
        this.parentItems = [];
        this.childrenItems = [];
        this.position = null;
        this.name = null;
        this.cancel = false;
        Object.assign(this, config);
    }
}
;

class OrgEventArgs {
    constructor(config = {}) {
        this.oldContext = null;
        this.context = null;
        this.parentItem = null;
        this.position = null;
        this.name = null;
        this.cancel = false;
        Object.assign(this, config);
    }
}
;

class RenderEventArgs {
    constructor(config = {}) {
        this.id = null;
        this.element = null;
        this.context = null;
        this.templateName = null;
        this.renderingMode = RenderingMode.Create;
        this.isCursor = false;
        this.isSelected = false;
        Object.assign(this, config);
    }
}
;

class SelectionEventArgs {
    constructor(config = {}) {
        this.selectedItems = [];
        this.newSelectedItems = [];
        this.cancel = false;
        Object.assign(this, config);
    }
}
;

class OrgConfig {
    constructor(config = {}) {
        this.navigationMode = NavigationMode.Default;
        this.pageFitMode = PageFitMode.FitToPage;
        this.alignBranches = false;
        this.minimalVisibility = Visibility.Dot;
        this.minimumVisibleLevels = 1;
        this.orientationType = OrientationType.Top;
        this.horizontalAlignment = HorizontalAlignmentType.Center;
        this.verticalAlignment = VerticalAlignmentType.Middle;
        this.arrowsDirection = GroupByType.None;
        this.showExtraArrows = false;
        this.extraArrowsMinimumSpace = 30;
        this.connectorType = ConnectorType.Squared;
        this.bevelSize = 4;
        this.elbowType = ElbowType.None;
        this.elbowDotSize = 4;
        this.emptyDiagramMessage = "Diagram is empty.";
        this.items = [];
        this.annotations = [];
        this.cursorItem = null;
        this.highlightItem = null;
        this.highlightGravityRadius = 40;
        this.selectedItems = [];
        this.hasSelectorCheckbox = Enabled.Auto;
        this.selectCheckBoxLabel = "Selected";
        this.selectionPathMode = SelectionPathMode.FullStack;
        this.templates = [];
        this.defaultTemplateName = null;
        this.hasButtons = Enabled.Auto;
        this.buttonsTemplate = null;
        this.normalLevelShift = 20;
        this.dotLevelShift = 20;
        this.lineLevelShift = 10;
        this.normalItemsInterval = 10;
        this.dotItemsInterval = 1;
        this.lineItemsInterval = 2;
        this.cousinsIntervalMultiplier = 5;
        this.itemTitleFirstFontColor = "#ffffff";
        this.itemTitleSecondFontColor = "#000080";
        this.minimizedItemShapeType = ShapeType.None;
        this.linesColor = "#c0c0c0";
        this.linesWidth = 1;
        this.linesType = LineType.Solid;
        this.highlightLinesColor = "#ff0000";
        this.highlightLinesWidth = 1;
        this.highlightLinesType = LineType.Solid;
        this.calloutMaximumVisibility = Visibility.Dot;
        this.showCallout = true;
        this.calloutPlacementOffset = 100;
        this.defaultCalloutTemplateName = null;
        this.calloutfillColor = "#000000";
        this.calloutBorderColor = null;
        this.calloutOffset = 4;
        this.calloutCornerRadius = 4;
        this.calloutPointerWidth = "10%";
        this.calloutLineWidth = 1;
        this.calloutOpacity = 0.2;
        this.childrenPlacementType = ChildrenPlacementType.Horizontal;
        this.leavesPlacementType = ChildrenPlacementType.Horizontal;
        this.placeAssistantsAboveChildren = true;
        this.placeAdvisersAboveChildren = true;
        this.maximumColumnsInMatrix = 6;
        this.buttonsPanelSize = 28;
        this.groupTitlePanelSize = 24;
        this.checkBoxPanelSize = 24;
        this.groupTitlePlacementType = AdviserPlacementType.Left;
        this.groupTitleOrientation = TextOrientationType.RotateRight;
        this.groupTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.groupTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.groupTitleFontSize = "12px";
        this.groupTitleFontFamily = "Arial";
        this.groupTitleColor = "#4169e1";
        this.groupTitleFontWeight = "normal";
        this.groupTitleFontStyle = "normal";
        this.groupTitleTemplate = null;
        this.levelTitlePanelSize = 24;
        this.levelTitlePlacementType = AdviserPlacementType.Left;
        this.levelTitlePlaceInside = false;
        this.levelTitleOrientation = TextOrientationType.Auto;
        this.levelTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.levelTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.levelTitleFontSize = "12px";
        this.levelTitleFontFamily = "Arial";
        this.levelTitleFontColor = "#ffffff";
        this.levelTitleColor = "#4169e1";
        this.levelTitleFontWeight = "normal";
        this.levelTitleFontStyle = "normal";
        this.levelTitleTemplate = null;
        this.levelBackgroundTemplate = null;
        this.distance = 3;
        this.scale = 1;
        this.minimumScale = 0.5;
        this.maximumScale = 2;
        this.showLabels = Enabled.Auto;
        this.labelSize = new Size(80, 24);
        this.labelOffset = 1;
        this.labelOrientation = TextOrientationType.Horizontal;
        this.labelPlacement = PlacementType.Top;
        this.labelFontSize = "10px";
        this.labelFontFamily = "Arial";
        this.labelColor = "#000000";
        this.labelFontWeight = "normal";
        this.labelFontStyle = "normal";
        this.enablePanning = true;
        this.autoSizeMinimum = new Size(800, 600);
        this.autoSizeMaximum = new Size(1024, 768);
        this.showFrame = false;
        this.frameInnerPadding = new Thickness(2, 2, 2, 2);
        this.frameOuterPadding = new Thickness(2, 2, 2, 2);
        this.padding = new Thickness(10, 10, 10, 10);
        Object.assign(this, config);
    }
}
;

class OrgDiagramComponent extends BaseDiagramComponent {
    constructor(host, zone) {
        super(host, zone, new TaskManagerFactory(OrgTaskManagerFactory));
        this.navigationMode = NavigationMode.Default;
        this.pageFitMode = PageFitMode.FitToPage;
        this.alignBranches = false;
        this.minimalVisibility = Visibility.Dot;
        this.minimumVisibleLevels = 1;
        this.orientationType = OrientationType.Top;
        this.horizontalAlignment = HorizontalAlignmentType.Center;
        this.verticalAlignment = VerticalAlignmentType.Middle;
        this.arrowsDirection = GroupByType.None;
        this.showExtraArrows = false;
        this.extraArrowsMinimumSpace = 30;
        this.connectorType = ConnectorType.Squared;
        this.bevelSize = 4;
        this.elbowType = ElbowType.None;
        this.elbowDotSize = 4;
        this.emptyDiagramMessage = "Diagram is empty.";
        this.items = [];
        this.annotations = [];
        this.cursorItem = null;
        this.highlightItem = null;
        this.highlightGravityRadius = 40;
        this.selectedItems = [];
        this.hasSelectorCheckbox = Enabled.Auto;
        this.selectCheckBoxLabel = "Selected";
        this.selectionPathMode = SelectionPathMode.FullStack;
        this.templates = [];
        this.defaultTemplateName = null;
        this.hasButtons = Enabled.Auto;
        this.buttonsTemplate = null;
        this.normalLevelShift = 20;
        this.dotLevelShift = 20;
        this.lineLevelShift = 10;
        this.normalItemsInterval = 10;
        this.dotItemsInterval = 1;
        this.lineItemsInterval = 2;
        this.cousinsIntervalMultiplier = 5;
        this.itemTitleFirstFontColor = "#ffffff";
        this.itemTitleSecondFontColor = "#000080";
        this.minimizedItemShapeType = ShapeType.None;
        this.linesColor = "#c0c0c0";
        this.linesWidth = 1;
        this.linesType = LineType.Solid;
        this.highlightLinesColor = "#ff0000";
        this.highlightLinesWidth = 1;
        this.highlightLinesType = LineType.Solid;
        this.calloutMaximumVisibility = Visibility.Dot;
        this.showCallout = true;
        this.calloutPlacementOffset = 100;
        this.defaultCalloutTemplateName = null;
        this.calloutfillColor = "#000000";
        this.calloutBorderColor = null;
        this.calloutOffset = 4;
        this.calloutCornerRadius = 4;
        this.calloutPointerWidth = "10%";
        this.calloutLineWidth = 1;
        this.calloutOpacity = 0.2;
        this.childrenPlacementType = ChildrenPlacementType.Horizontal;
        this.leavesPlacementType = ChildrenPlacementType.Horizontal;
        this.placeAssistantsAboveChildren = true;
        this.placeAdvisersAboveChildren = true;
        this.maximumColumnsInMatrix = 6;
        this.buttonsPanelSize = 28;
        this.groupTitlePanelSize = 24;
        this.checkBoxPanelSize = 24;
        this.groupTitlePlacementType = AdviserPlacementType.Left;
        this.groupTitleOrientation = TextOrientationType.RotateRight;
        this.groupTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.groupTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.groupTitleFontSize = "12px";
        this.groupTitleFontFamily = "Arial";
        this.groupTitleColor = "#4169e1";
        this.groupTitleFontWeight = "normal";
        this.groupTitleFontStyle = "normal";
        this.groupTitleTemplate = null;
        this.levelTitlePanelSize = 24;
        this.levelTitlePlacementType = AdviserPlacementType.Left;
        this.levelTitlePlaceInside = false;
        this.levelTitleOrientation = TextOrientationType.Auto;
        this.levelTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.levelTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.levelTitleFontSize = "12px";
        this.levelTitleFontFamily = "Arial";
        this.levelTitleFontColor = "#ffffff";
        this.levelTitleColor = "#4169e1";
        this.levelTitleFontWeight = "normal";
        this.levelTitleFontStyle = "normal";
        this.levelTitleTemplate = null;
        this.levelBackgroundTemplate = null;
        this.distance = 3;
        this.scale = 1;
        this.minimumScale = 0.5;
        this.maximumScale = 2;
        this.showLabels = Enabled.Auto;
        this.labelSize = new Size(80, 24);
        this.labelOffset = 1;
        this.labelOrientation = TextOrientationType.Horizontal;
        this.labelPlacement = PlacementType.Top;
        this.labelFontSize = "10px";
        this.labelFontFamily = "Arial";
        this.labelColor = "#000000";
        this.labelFontWeight = "normal";
        this.labelFontStyle = "normal";
        this.enablePanning = true;
        this.autoSizeMinimum = new Size(800, 600);
        this.autoSizeMaximum = new Size(1024, 768);
        this.showFrame = false;
        this.frameInnerPadding = new Thickness(2, 2, 2, 2);
        this.frameOuterPadding = new Thickness(2, 2, 2, 2);
        this.padding = new Thickness(10, 10, 10, 10);
        this.onHighlightChanging = new EventEmitter(false);
        this.onHighlightChanged = new EventEmitter();
        this.onCursorChanging = new EventEmitter(false);
        this.onCursorChanged = new EventEmitter();
        this.onSelectionChanging = new EventEmitter(false);
        this.onSelectionChanged = new EventEmitter();
    }
    ngOnChanges(changes) {
        var config = new OrgConfig(this);
        const { highlightItem, cursorItem, selectedItems } = config;
        this.state = {
            ...this.state,
            config,
            highlightItem,
            cursorItem,
            selectedItems,
            centerOnCursor: this.centerOnCursor
        };
        this.render();
    }
    _onHighlightChanging(event, itemId, newItemId) {
        var newEvent = new OrgEventArgs({
            ...(this.getEventArgs(itemId, newItemId)),
            event
        });
        this.onHighlightChanging.emit(newEvent);
        return newEvent;
    }
    ;
    _onHighlightChanged(eventArgs) {
        this.onHighlightChanged.emit(eventArgs);
    }
    ;
    _onCursorChanging(event, itemId, newItemId) {
        var newEvent = new OrgEventArgs({
            ...(this.getEventArgs(itemId, newItemId)),
            event
        });
        this.onCursorChanging.emit(newEvent);
        return newEvent;
    }
    ;
    _onCursorChanged(eventArgs) {
        this.onCursorChanged.emit(eventArgs);
    }
    ;
    _onSelectionChanging(event, selectedItems, newSelectedItems) {
        var newEvent = new SelectionEventArgs({
            selectedItems,
            newSelectedItems,
            event
        });
        this.onSelectionChanging.emit(newEvent);
        return newEvent;
    }
    ;
    _onSelectionChanged(eventArgs) {
        this.onSelectionChanged.emit(eventArgs);
    }
    ;
}
OrgDiagramComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: OrgDiagramComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
OrgDiagramComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: OrgDiagramComponent, selector: "org-diagram", inputs: { navigationMode: "navigationMode", pageFitMode: "pageFitMode", alignBranches: "alignBranches", minimalVisibility: "minimalVisibility", minimumVisibleLevels: "minimumVisibleLevels", orientationType: "orientationType", horizontalAlignment: "horizontalAlignment", verticalAlignment: "verticalAlignment", arrowsDirection: "arrowsDirection", showExtraArrows: "showExtraArrows", extraArrowsMinimumSpace: "extraArrowsMinimumSpace", connectorType: "connectorType", bevelSize: "bevelSize", elbowType: "elbowType", elbowDotSize: "elbowDotSize", emptyDiagramMessage: "emptyDiagramMessage", items: "items", annotations: "annotations", cursorItem: "cursorItem", highlightItem: "highlightItem", highlightGravityRadius: "highlightGravityRadius", selectedItems: "selectedItems", hasSelectorCheckbox: "hasSelectorCheckbox", selectCheckBoxLabel: "selectCheckBoxLabel", selectionPathMode: "selectionPathMode", templates: "templates", defaultTemplateName: "defaultTemplateName", hasButtons: "hasButtons", buttonsTemplate: "buttonsTemplate", normalLevelShift: "normalLevelShift", dotLevelShift: "dotLevelShift", lineLevelShift: "lineLevelShift", normalItemsInterval: "normalItemsInterval", dotItemsInterval: "dotItemsInterval", lineItemsInterval: "lineItemsInterval", cousinsIntervalMultiplier: "cousinsIntervalMultiplier", itemTitleFirstFontColor: "itemTitleFirstFontColor", itemTitleSecondFontColor: "itemTitleSecondFontColor", minimizedItemShapeType: "minimizedItemShapeType", linesColor: "linesColor", linesWidth: "linesWidth", linesType: "linesType", highlightLinesColor: "highlightLinesColor", highlightLinesWidth: "highlightLinesWidth", highlightLinesType: "highlightLinesType", calloutMaximumVisibility: "calloutMaximumVisibility", showCallout: "showCallout", calloutPlacementOffset: "calloutPlacementOffset", defaultCalloutTemplateName: "defaultCalloutTemplateName", calloutfillColor: "calloutfillColor", calloutBorderColor: "calloutBorderColor", calloutOffset: "calloutOffset", calloutCornerRadius: "calloutCornerRadius", calloutPointerWidth: "calloutPointerWidth", calloutLineWidth: "calloutLineWidth", calloutOpacity: "calloutOpacity", childrenPlacementType: "childrenPlacementType", leavesPlacementType: "leavesPlacementType", placeAssistantsAboveChildren: "placeAssistantsAboveChildren", placeAdvisersAboveChildren: "placeAdvisersAboveChildren", maximumColumnsInMatrix: "maximumColumnsInMatrix", buttonsPanelSize: "buttonsPanelSize", groupTitlePanelSize: "groupTitlePanelSize", checkBoxPanelSize: "checkBoxPanelSize", groupTitlePlacementType: "groupTitlePlacementType", groupTitleOrientation: "groupTitleOrientation", groupTitleVerticalAlignment: "groupTitleVerticalAlignment", groupTitleHorizontalAlignment: "groupTitleHorizontalAlignment", groupTitleFontSize: "groupTitleFontSize", groupTitleFontFamily: "groupTitleFontFamily", groupTitleColor: "groupTitleColor", groupTitleFontWeight: "groupTitleFontWeight", groupTitleFontStyle: "groupTitleFontStyle", groupTitleTemplate: "groupTitleTemplate", levelTitlePanelSize: "levelTitlePanelSize", levelTitlePlacementType: "levelTitlePlacementType", levelTitlePlaceInside: "levelTitlePlaceInside", levelTitleOrientation: "levelTitleOrientation", levelTitleVerticalAlignment: "levelTitleVerticalAlignment", levelTitleHorizontalAlignment: "levelTitleHorizontalAlignment", levelTitleFontSize: "levelTitleFontSize", levelTitleFontFamily: "levelTitleFontFamily", levelTitleFontColor: "levelTitleFontColor", levelTitleColor: "levelTitleColor", levelTitleFontWeight: "levelTitleFontWeight", levelTitleFontStyle: "levelTitleFontStyle", levelTitleTemplate: "levelTitleTemplate", levelBackgroundTemplate: "levelBackgroundTemplate", distance: "distance", scale: "scale", minimumScale: "minimumScale", maximumScale: "maximumScale", showLabels: "showLabels", labelSize: "labelSize", labelOffset: "labelOffset", labelOrientation: "labelOrientation", labelPlacement: "labelPlacement", labelFontSize: "labelFontSize", labelFontFamily: "labelFontFamily", labelColor: "labelColor", labelFontWeight: "labelFontWeight", labelFontStyle: "labelFontStyle", enablePanning: "enablePanning", autoSizeMinimum: "autoSizeMinimum", autoSizeMaximum: "autoSizeMaximum", showFrame: "showFrame", frameInnerPadding: "frameInnerPadding", frameOuterPadding: "frameOuterPadding", padding: "padding" }, outputs: { onHighlightChanging: "onHighlightChanging", onHighlightChanged: "onHighlightChanged", onCursorChanging: "onCursorChanging", onCursorChanged: "onCursorChanged", onSelectionChanging: "onSelectionChanging", onSelectionChanged: "onSelectionChanged" }, usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<!-- root control panel -->\n<div #controlPanelRef\n  class=\"control-panel\"\n  [ngStyle]=\"controlPanelStyle\"\n  (keydown)=\"onKeyDown($event)\"\n  tabIndex=\"0\"\n>\n  <div *ngIf=\"framePlaceholder\"\n    #frameMousePanelRef\n    class=\"frame-mouse-panel\"\n    [ngStyle]=\"frameMousePanelStyle\"\n    (click)=\"onFrameClick($event)\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n  >\n    <div #framePlaceholderRef\n      class=\"frame-placeholder\" \n      [ngStyle]=\"framePlaceholderStyle\"\n    >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: framePlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div *ngIf=\"titlesPlaceholder\"\n    #titlesMousePanelRef\n    class=\"titles-mouse-panel\"\n    [ngStyle]=\"titlesMousePanelStyle\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n    (click)=\"onFrameClick($event)\"\n  >\n    <div #titlesPlaceholderRef\n      [ngStyle]=\"titlesPlaceholderStyle\"\n      class=\"titles-placeholder\"\n     >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: titlesPlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div\n    #scrollPanelRef\n    class=\"scroll-panel\"\n    [ngStyle]=\"scrollPanelStyle\"\n    (scroll)=\"onScroll($event)\"\n    [scrollLeft]=\"placeholderOffset ? placeholderOffset.x : undefined\"\n    [scrollTop]=\"placeholderOffset ? placeholderOffset.y : undefined\"\n  >\n    <div #mousePanelRef\n      class=\"mouse-panel\"\n      [ngStyle]=\"mousePanelStyle\"\n      (mousemove)=\"onMouseMove($event)\"\n      (click)=\"onClick($event)\"\n      (change)=\"onCheckboxChange($event)\"\n    >\n      <div #placeholderRef\n        class=\"placeholder\"\n        [ngStyle]=\"placeholderStyle\"\n      >\n        <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: placeholder}\"></ng-container>\n        <div *ngIf=\"calloutPlaceholder\"\n          #calloutPlaceholderRef\n          class=\"callout-placeholder\"\n          [ngStyle]=\"calloutPlaceholderStyle\"\n        >\n          <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: calloutPlaceholder}\"></ng-container>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!--Templates: -->\n<ng-template #layerTemplate let-placeholder>\n  <div *ngFor=\"let layer of placeholder.layers\" class=\"layer\">\n    <ng-container *ngIf=\"layer\">\n      <div *ngFor=\"let label of layer.labels\" class=\"label\" [ngStyle]= \"label.style\">\n        <rotated-text\n          [width]=\"label.width\"\n          [height]=\"label.height\"\n          [orientation]=\"label.orientation\"\n          [horizontalAlignment]=\"label.horizontalAlignment\"\n          [verticalAlignment]=\"label.verticalAlignment\"\n        >{{label.label}}</rotated-text>\n      </div>\n      <svg \n        *ngIf=\"layer.polylines.length > 0\"\n        attr.height.px=\"{{placeholder.size.height}}\"\n        attr.width.px=\"{{placeholder.size.width}}\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n        [ngStyle]=\"{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}\"\n      >\n        <path *ngFor=\"let path of layer.polylines\" [attr.d]=\"path.data\" [ngStyle]=\"path.style\"></path>\n      </svg>\n      <div *ngFor=\"let item of layer.items;\" class=\"template\" [ngStyle]=\"item.style\">\n        <ng-container [ngSwitch]=\"item.templateType\">\n          <ng-container *ngSwitchCase=\"'itemTemplate'\">\n            <bp-item [itemConfig]=\"item.context.context\" [itemTitleFirstFontColor]=\"item.context.itemTitleFirstFontColor\" [itemTitleSecondFontColor]=\"item.context.itemTitleSecondFontColor\"></bp-item>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'checkboxTemplate'\">\n            <bp-checkbox [id]=\"item.context.id\" [isSelected]=\"item.context.isSelected\" [label]=\"item.context.selectCheckBoxLabel\"></bp-checkbox>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'groupTitleTemplate'\">\n            <bp-group-title [options]=\"item.context\" [itemConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-group-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'cursorTemplate'\">\n            <bp-cursor [templateConfig]=\"item.context.templateConfig\"></bp-cursor>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'highlightTemplate'\">\n            <bp-highlight [templateConfig]=\"item.context.templateConfig\"></bp-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'dotHighlightTemplate'\">\n            <bp-dot-highlight [templateConfig]=\"item.context.templateConfig\"></bp-dot-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelTitleTemplate'\">\n            <bp-level-title [options]=\"item.context\" [annotationConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-level-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelBackgroundTemplate'\">\n            <bp-level-background [annotationConfig]=\"item.context.context\"></bp-level-background>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'labelAnnotationTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.title}}</div>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'annotationLabelTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.label}}</div>\n          </ng-container>\n          <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"item.templateRef; context: item.context\"></ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n</ng-template>\n", styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"], components: [{ type: RotatedText, selector: "rotated-text", inputs: ["width", "height", "orientation", "horizontalAlignment", "verticalAlignment"] }, { type: ItemComponent, selector: "bp-item", inputs: ["itemTitleFirstFontColor", "itemTitleSecondFontColor", "itemConfig"] }, { type: CheckboxComponent, selector: "bp-checkbox", inputs: ["id", "label", "isSelected"] }, { type: GroupTitleComponent, selector: "bp-group-title", inputs: ["options", "itemConfig", "width", "height"] }, { type: CursorComponent, selector: "bp-cursor", inputs: ["templateConfig"] }, { type: HighlightComponent, selector: "bp-highlight", inputs: ["templateConfig"] }, { type: DotHighlightComponent, selector: "bp-dot-highlight", inputs: ["templateConfig"] }, { type: LevelTitleComponent, selector: "bp-level-title", inputs: ["options", "annotationConfig", "width", "height"] }, { type: LevelBackgroundComponent, selector: "bp-level-background", inputs: ["annotationConfig"] }], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i10.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i10.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i10.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i10.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i10.NgSwitchDefault, selector: "[ngSwitchDefault]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: OrgDiagramComponent, decorators: [{
            type: Component,
            args: [{ selector: 'org-diagram', template: "<!-- root control panel -->\n<div #controlPanelRef\n  class=\"control-panel\"\n  [ngStyle]=\"controlPanelStyle\"\n  (keydown)=\"onKeyDown($event)\"\n  tabIndex=\"0\"\n>\n  <div *ngIf=\"framePlaceholder\"\n    #frameMousePanelRef\n    class=\"frame-mouse-panel\"\n    [ngStyle]=\"frameMousePanelStyle\"\n    (click)=\"onFrameClick($event)\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n  >\n    <div #framePlaceholderRef\n      class=\"frame-placeholder\" \n      [ngStyle]=\"framePlaceholderStyle\"\n    >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: framePlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div *ngIf=\"titlesPlaceholder\"\n    #titlesMousePanelRef\n    class=\"titles-mouse-panel\"\n    [ngStyle]=\"titlesMousePanelStyle\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n    (click)=\"onFrameClick($event)\"\n  >\n    <div #titlesPlaceholderRef\n      [ngStyle]=\"titlesPlaceholderStyle\"\n      class=\"titles-placeholder\"\n     >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: titlesPlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div\n    #scrollPanelRef\n    class=\"scroll-panel\"\n    [ngStyle]=\"scrollPanelStyle\"\n    (scroll)=\"onScroll($event)\"\n    [scrollLeft]=\"placeholderOffset ? placeholderOffset.x : undefined\"\n    [scrollTop]=\"placeholderOffset ? placeholderOffset.y : undefined\"\n  >\n    <div #mousePanelRef\n      class=\"mouse-panel\"\n      [ngStyle]=\"mousePanelStyle\"\n      (mousemove)=\"onMouseMove($event)\"\n      (click)=\"onClick($event)\"\n      (change)=\"onCheckboxChange($event)\"\n    >\n      <div #placeholderRef\n        class=\"placeholder\"\n        [ngStyle]=\"placeholderStyle\"\n      >\n        <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: placeholder}\"></ng-container>\n        <div *ngIf=\"calloutPlaceholder\"\n          #calloutPlaceholderRef\n          class=\"callout-placeholder\"\n          [ngStyle]=\"calloutPlaceholderStyle\"\n        >\n          <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: calloutPlaceholder}\"></ng-container>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!--Templates: -->\n<ng-template #layerTemplate let-placeholder>\n  <div *ngFor=\"let layer of placeholder.layers\" class=\"layer\">\n    <ng-container *ngIf=\"layer\">\n      <div *ngFor=\"let label of layer.labels\" class=\"label\" [ngStyle]= \"label.style\">\n        <rotated-text\n          [width]=\"label.width\"\n          [height]=\"label.height\"\n          [orientation]=\"label.orientation\"\n          [horizontalAlignment]=\"label.horizontalAlignment\"\n          [verticalAlignment]=\"label.verticalAlignment\"\n        >{{label.label}}</rotated-text>\n      </div>\n      <svg \n        *ngIf=\"layer.polylines.length > 0\"\n        attr.height.px=\"{{placeholder.size.height}}\"\n        attr.width.px=\"{{placeholder.size.width}}\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n        [ngStyle]=\"{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}\"\n      >\n        <path *ngFor=\"let path of layer.polylines\" [attr.d]=\"path.data\" [ngStyle]=\"path.style\"></path>\n      </svg>\n      <div *ngFor=\"let item of layer.items;\" class=\"template\" [ngStyle]=\"item.style\">\n        <ng-container [ngSwitch]=\"item.templateType\">\n          <ng-container *ngSwitchCase=\"'itemTemplate'\">\n            <bp-item [itemConfig]=\"item.context.context\" [itemTitleFirstFontColor]=\"item.context.itemTitleFirstFontColor\" [itemTitleSecondFontColor]=\"item.context.itemTitleSecondFontColor\"></bp-item>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'checkboxTemplate'\">\n            <bp-checkbox [id]=\"item.context.id\" [isSelected]=\"item.context.isSelected\" [label]=\"item.context.selectCheckBoxLabel\"></bp-checkbox>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'groupTitleTemplate'\">\n            <bp-group-title [options]=\"item.context\" [itemConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-group-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'cursorTemplate'\">\n            <bp-cursor [templateConfig]=\"item.context.templateConfig\"></bp-cursor>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'highlightTemplate'\">\n            <bp-highlight [templateConfig]=\"item.context.templateConfig\"></bp-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'dotHighlightTemplate'\">\n            <bp-dot-highlight [templateConfig]=\"item.context.templateConfig\"></bp-dot-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelTitleTemplate'\">\n            <bp-level-title [options]=\"item.context\" [annotationConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-level-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelBackgroundTemplate'\">\n            <bp-level-background [annotationConfig]=\"item.context.context\"></bp-level-background>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'labelAnnotationTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.title}}</div>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'annotationLabelTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.label}}</div>\n          </ng-container>\n          <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"item.templateRef; context: item.context\"></ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n</ng-template>\n", styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { navigationMode: [{
                type: Input
            }], pageFitMode: [{
                type: Input
            }], alignBranches: [{
                type: Input
            }], minimalVisibility: [{
                type: Input
            }], minimumVisibleLevels: [{
                type: Input
            }], orientationType: [{
                type: Input
            }], horizontalAlignment: [{
                type: Input
            }], verticalAlignment: [{
                type: Input
            }], arrowsDirection: [{
                type: Input
            }], showExtraArrows: [{
                type: Input
            }], extraArrowsMinimumSpace: [{
                type: Input
            }], connectorType: [{
                type: Input
            }], bevelSize: [{
                type: Input
            }], elbowType: [{
                type: Input
            }], elbowDotSize: [{
                type: Input
            }], emptyDiagramMessage: [{
                type: Input
            }], items: [{
                type: Input
            }], annotations: [{
                type: Input
            }], cursorItem: [{
                type: Input
            }], highlightItem: [{
                type: Input
            }], highlightGravityRadius: [{
                type: Input
            }], selectedItems: [{
                type: Input
            }], hasSelectorCheckbox: [{
                type: Input
            }], selectCheckBoxLabel: [{
                type: Input
            }], selectionPathMode: [{
                type: Input
            }], templates: [{
                type: Input
            }], defaultTemplateName: [{
                type: Input
            }], hasButtons: [{
                type: Input
            }], buttonsTemplate: [{
                type: Input
            }], normalLevelShift: [{
                type: Input
            }], dotLevelShift: [{
                type: Input
            }], lineLevelShift: [{
                type: Input
            }], normalItemsInterval: [{
                type: Input
            }], dotItemsInterval: [{
                type: Input
            }], lineItemsInterval: [{
                type: Input
            }], cousinsIntervalMultiplier: [{
                type: Input
            }], itemTitleFirstFontColor: [{
                type: Input
            }], itemTitleSecondFontColor: [{
                type: Input
            }], minimizedItemShapeType: [{
                type: Input
            }], linesColor: [{
                type: Input
            }], linesWidth: [{
                type: Input
            }], linesType: [{
                type: Input
            }], highlightLinesColor: [{
                type: Input
            }], highlightLinesWidth: [{
                type: Input
            }], highlightLinesType: [{
                type: Input
            }], calloutMaximumVisibility: [{
                type: Input
            }], showCallout: [{
                type: Input
            }], calloutPlacementOffset: [{
                type: Input
            }], defaultCalloutTemplateName: [{
                type: Input
            }], calloutfillColor: [{
                type: Input
            }], calloutBorderColor: [{
                type: Input
            }], calloutOffset: [{
                type: Input
            }], calloutCornerRadius: [{
                type: Input
            }], calloutPointerWidth: [{
                type: Input
            }], calloutLineWidth: [{
                type: Input
            }], calloutOpacity: [{
                type: Input
            }], childrenPlacementType: [{
                type: Input
            }], leavesPlacementType: [{
                type: Input
            }], placeAssistantsAboveChildren: [{
                type: Input
            }], placeAdvisersAboveChildren: [{
                type: Input
            }], maximumColumnsInMatrix: [{
                type: Input
            }], buttonsPanelSize: [{
                type: Input
            }], groupTitlePanelSize: [{
                type: Input
            }], checkBoxPanelSize: [{
                type: Input
            }], groupTitlePlacementType: [{
                type: Input
            }], groupTitleOrientation: [{
                type: Input
            }], groupTitleVerticalAlignment: [{
                type: Input
            }], groupTitleHorizontalAlignment: [{
                type: Input
            }], groupTitleFontSize: [{
                type: Input
            }], groupTitleFontFamily: [{
                type: Input
            }], groupTitleColor: [{
                type: Input
            }], groupTitleFontWeight: [{
                type: Input
            }], groupTitleFontStyle: [{
                type: Input
            }], groupTitleTemplate: [{
                type: Input
            }], levelTitlePanelSize: [{
                type: Input
            }], levelTitlePlacementType: [{
                type: Input
            }], levelTitlePlaceInside: [{
                type: Input
            }], levelTitleOrientation: [{
                type: Input
            }], levelTitleVerticalAlignment: [{
                type: Input
            }], levelTitleHorizontalAlignment: [{
                type: Input
            }], levelTitleFontSize: [{
                type: Input
            }], levelTitleFontFamily: [{
                type: Input
            }], levelTitleFontColor: [{
                type: Input
            }], levelTitleColor: [{
                type: Input
            }], levelTitleFontWeight: [{
                type: Input
            }], levelTitleFontStyle: [{
                type: Input
            }], levelTitleTemplate: [{
                type: Input
            }], levelBackgroundTemplate: [{
                type: Input
            }], distance: [{
                type: Input
            }], scale: [{
                type: Input
            }], minimumScale: [{
                type: Input
            }], maximumScale: [{
                type: Input
            }], showLabels: [{
                type: Input
            }], labelSize: [{
                type: Input
            }], labelOffset: [{
                type: Input
            }], labelOrientation: [{
                type: Input
            }], labelPlacement: [{
                type: Input
            }], labelFontSize: [{
                type: Input
            }], labelFontFamily: [{
                type: Input
            }], labelColor: [{
                type: Input
            }], labelFontWeight: [{
                type: Input
            }], labelFontStyle: [{
                type: Input
            }], enablePanning: [{
                type: Input
            }], autoSizeMinimum: [{
                type: Input
            }], autoSizeMaximum: [{
                type: Input
            }], showFrame: [{
                type: Input
            }], frameInnerPadding: [{
                type: Input
            }], frameOuterPadding: [{
                type: Input
            }], padding: [{
                type: Input
            }], onHighlightChanging: [{
                type: Output
            }], onHighlightChanged: [{
                type: Output
            }], onCursorChanging: [{
                type: Output
            }], onCursorChanged: [{
                type: Output
            }], onSelectionChanging: [{
                type: Output
            }], onSelectionChanged: [{
                type: Output
            }] } });

class FamConfig {
    constructor(config = {}) {
        this.navigationMode = NavigationMode.Default;
        this.pageFitMode = PageFitMode.FitToPage;
        this.minimalVisibility = Visibility.Dot;
        this.minimumVisibleLevels = 0;
        this.orientationType = OrientationType.Top;
        this.verticalAlignment = VerticalAlignmentType.Middle;
        this.arrowsDirection = GroupByType.None;
        this.showExtraArrows = true;
        this.extraArrowsMinimumSpace = 30;
        this.groupByType = GroupByType.Children;
        this.alignBylevels = true;
        this.enableMatrixLayout = false;
        this.minimumMatrixSize = 4;
        this.maximumColumnsInMatrix = 6;
        this.hideGrandParentsConnectors = false;
        this.bevelSize = 4;
        this.elbowType = ElbowType.Round;
        this.elbowDotSize = 4;
        this.emptyDiagramMessage = "Diagram is empty.";
        this.items = [];
        this.annotations = [];
        this.cursorItem = null;
        this.highlightItem = null;
        this.highlightGravityRadius = 40;
        this.selectedItems = [];
        this.hasSelectorCheckbox = Enabled.Auto;
        this.selectCheckBoxLabel = "Selected";
        this.selectionPathMode = SelectionPathMode.None;
        this.neighboursSelectionMode = NeighboursSelectionMode.ParentsAndChildren;
        this.templates = [];
        this.defaultTemplateName = null;
        this.defaultLabelAnnotationTemplate = null;
        this.hasButtons = Enabled.Auto;
        this.buttonsTemplate = null;
        this.normalLevelShift = 20;
        this.dotLevelShift = 20;
        this.lineLevelShift = 10;
        this.normalItemsInterval = 10;
        this.dotItemsInterval = 1;
        this.lineItemsInterval = 2;
        this.cousinsIntervalMultiplier = 5;
        this.itemTitleFirstFontColor = "#ffffff";
        this.itemTitleSecondFontColor = "#000080";
        this.minimizedItemShapeType = ShapeType.None;
        this.linesColor = "#c0c0c0";
        this.linesWidth = 1;
        this.linesType = LineType.Solid;
        this.showNeigboursConnectorsHighlighted = false;
        this.highlightLinesColor = "#ff0000";
        this.highlightLinesWidth = 1;
        this.highlightLinesType = LineType.Solid;
        this.linesPalette = [];
        this.calloutMaximumVisibility = Visibility.Dot;
        this.showCallout = true;
        this.calloutPlacementOffset = 100;
        this.defaultCalloutTemplateName = null;
        this.calloutfillColor = "#000000";
        this.calloutBorderColor = null;
        this.calloutOffset = 4;
        this.calloutCornerRadius = 4;
        this.calloutPointerWidth = "10%";
        this.calloutLineWidth = 1;
        this.calloutOpacity = 0.2;
        this.buttonsPanelSize = 28;
        this.groupTitlePanelSize = 24;
        this.checkBoxPanelSize = 24;
        this.groupTitlePlacementType = AdviserPlacementType.Left;
        this.groupTitleOrientation = TextOrientationType.RotateRight;
        this.groupTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.groupTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.groupTitleFontSize = "12px";
        this.groupTitleFontFamily = "Arial";
        this.groupTitleColor = "#4169e1";
        this.groupTitleFontWeight = "normal";
        this.groupTitleFontStyle = "normal";
        this.groupTitleTemplate = null;
        this.levelTitlePanelSize = 24;
        this.levelTitlePlacementType = AdviserPlacementType.Left;
        this.levelTitlePlaceInside = false;
        this.levelTitleOrientation = TextOrientationType.Auto;
        this.levelTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.levelTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.levelTitleFontSize = "12px";
        this.levelTitleFontFamily = "Arial";
        this.levelTitleFontColor = "#ffffff";
        this.levelTitleColor = "#4169e1";
        this.levelTitleFontWeight = "normal";
        this.levelTitleFontStyle = "normal";
        this.levelTitleTemplate = null;
        this.levelBackgroundTemplate = null;
        this.distance = 3;
        this.scale = 1;
        this.minimumScale = 0.5;
        this.maximumScale = 1;
        this.showLabels = Enabled.Auto;
        this.labelSize = new Size(80, 24);
        this.labelOffset = 1;
        this.labelOrientation = TextOrientationType.Horizontal;
        this.labelPlacement = PlacementType.Top;
        this.labelFontSize = "10px";
        this.labelFontFamily = "Arial";
        this.labelColor = "#000000";
        this.labelFontWeight = "normal";
        this.labelFontStyle = "normal";
        this.enablePanning = true;
        this.autoSizeMinimum = new Size(800, 600);
        this.autoSizeMaximum = new Size(1024, 768);
        this.showFrame = false;
        this.frameInnerPadding = new Thickness(2, 2, 2, 2);
        this.frameOuterPadding = new Thickness(2, 2, 2, 2);
        this.padding = new Thickness(10, 10, 10, 10);
        Object.assign(this, config);
    }
}
;

class FamDiagramComponent extends BaseDiagramComponent {
    constructor(host, zone) {
        super(host, zone, new TaskManagerFactory(FamTaskManagerFactory));
        this.navigationMode = NavigationMode.Default;
        this.pageFitMode = PageFitMode.FitToPage;
        this.minimalVisibility = Visibility.Dot;
        this.minimumVisibleLevels = 0;
        this.orientationType = OrientationType.Top;
        this.verticalAlignment = VerticalAlignmentType.Middle;
        this.arrowsDirection = GroupByType.None;
        this.showExtraArrows = true;
        this.extraArrowsMinimumSpace = 30;
        this.groupByType = GroupByType.Children;
        this.alignBylevels = true;
        this.enableMatrixLayout = false;
        this.minimumMatrixSize = 4;
        this.maximumColumnsInMatrix = 6;
        this.hideGrandParentsConnectors = false;
        this.bevelSize = 4;
        this.elbowType = ElbowType.Round;
        this.elbowDotSize = 4;
        this.emptyDiagramMessage = "Diagram is empty.";
        this.items = [];
        this.annotations = [];
        this.cursorItem = null;
        this.highlightItem = null;
        this.highlightGravityRadius = 40;
        this.selectedItems = [];
        this.hasSelectorCheckbox = Enabled.Auto;
        this.selectCheckBoxLabel = "Selected";
        this.selectionPathMode = SelectionPathMode.None;
        this.neighboursSelectionMode = NeighboursSelectionMode.ParentsAndChildren;
        this.templates = [];
        this.defaultTemplateName = null;
        this.defaultLabelAnnotationTemplate = null;
        this.hasButtons = Enabled.Auto;
        this.buttonsTemplate = null;
        this.normalLevelShift = 20;
        this.dotLevelShift = 20;
        this.lineLevelShift = 10;
        this.normalItemsInterval = 10;
        this.dotItemsInterval = 1;
        this.lineItemsInterval = 2;
        this.cousinsIntervalMultiplier = 5;
        this.itemTitleFirstFontColor = "#ffffff";
        this.itemTitleSecondFontColor = "#000080";
        this.minimizedItemShapeType = ShapeType.None;
        this.linesColor = "#c0c0c0";
        this.linesWidth = 1;
        this.linesType = LineType.Solid;
        this.showNeigboursConnectorsHighlighted = false;
        this.highlightLinesColor = "#ff0000";
        this.highlightLinesWidth = 1;
        this.highlightLinesType = LineType.Solid;
        this.linesPalette = [];
        this.calloutMaximumVisibility = Visibility.Dot;
        this.showCallout = true;
        this.calloutPlacementOffset = 100;
        this.defaultCalloutTemplateName = null;
        this.calloutfillColor = "#000000";
        this.calloutBorderColor = null;
        this.calloutOffset = 4;
        this.calloutCornerRadius = 4;
        this.calloutPointerWidth = "10%";
        this.calloutLineWidth = 1;
        this.calloutOpacity = 0.2;
        this.buttonsPanelSize = 28;
        this.groupTitlePanelSize = 24;
        this.checkBoxPanelSize = 24;
        this.groupTitlePlacementType = AdviserPlacementType.Left;
        this.groupTitleOrientation = TextOrientationType.RotateRight;
        this.groupTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.groupTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.groupTitleFontSize = "12px";
        this.groupTitleFontFamily = "Arial";
        this.groupTitleColor = "#4169e1";
        this.groupTitleFontWeight = "normal";
        this.groupTitleFontStyle = "normal";
        this.groupTitleTemplate = null;
        this.levelTitlePanelSize = 24;
        this.levelTitlePlacementType = AdviserPlacementType.Left;
        this.levelTitlePlaceInside = false;
        this.levelTitleOrientation = TextOrientationType.Auto;
        this.levelTitleVerticalAlignment = VerticalAlignmentType.Middle;
        this.levelTitleHorizontalAlignment = HorizontalAlignmentType.Center;
        this.levelTitleFontSize = "12px";
        this.levelTitleFontFamily = "Arial";
        this.levelTitleFontColor = "#ffffff";
        this.levelTitleColor = "#4169e1";
        this.levelTitleFontWeight = "normal";
        this.levelTitleFontStyle = "normal";
        this.levelTitleTemplate = null;
        this.levelBackgroundTemplate = null;
        this.distance = 3;
        this.scale = 1;
        this.minimumScale = 0.5;
        this.maximumScale = 1;
        this.showLabels = Enabled.Auto;
        this.labelSize = new Size(80, 24);
        this.labelOffset = 1;
        this.labelOrientation = TextOrientationType.Horizontal;
        this.labelPlacement = PlacementType.Top;
        this.labelFontSize = "10px";
        this.labelFontFamily = "Arial";
        this.labelColor = "#000000";
        this.labelFontWeight = "normal";
        this.labelFontStyle = "normal";
        this.enablePanning = true;
        this.autoSizeMinimum = new Size(800, 600);
        this.autoSizeMaximum = new Size(1024, 768);
        this.showFrame = false;
        this.frameInnerPadding = new Thickness(2, 2, 2, 2);
        this.frameOuterPadding = new Thickness(2, 2, 2, 2);
        this.padding = new Thickness(10, 10, 10, 10);
        this.onHighlightChanging = new EventEmitter(false);
        this.onHighlightChanged = new EventEmitter();
        this.onCursorChanging = new EventEmitter(false);
        this.onCursorChanged = new EventEmitter();
        this.onSelectionChanging = new EventEmitter(false);
        this.onSelectionChanged = new EventEmitter();
    }
    ngOnChanges(changes) {
        var config = new FamConfig(this);
        const { highlightItem, cursorItem, selectedItems } = config;
        this.state = {
            ...this.state,
            config,
            highlightItem,
            cursorItem,
            selectedItems,
            centerOnCursor: this.centerOnCursor
        };
        this.render();
    }
    _onHighlightChanging(event, itemId, newItemId) {
        var newEvent = new FamEventArgs({
            ...(this.getEventArgs(itemId, newItemId)),
            event
        });
        this.onHighlightChanging.emit(newEvent);
        return newEvent;
    }
    ;
    _onHighlightChanged(eventArgs) {
        this.onHighlightChanged.emit(eventArgs);
    }
    ;
    _onCursorChanging(event, itemId, newItemId) {
        var newEvent = new FamEventArgs({
            ...(this.getEventArgs(itemId, newItemId)),
            event
        });
        this.onCursorChanging.emit(newEvent);
        return newEvent;
    }
    ;
    _onCursorChanged(eventArgs) {
        this.onCursorChanged.emit(eventArgs);
    }
    ;
    _onSelectionChanging(event, selectedItems, newSelectedItems) {
        var newEvent = new SelectionEventArgs({
            selectedItems,
            newSelectedItems,
            event
        });
        this.onSelectionChanging.emit(newEvent);
        return newEvent;
    }
    ;
    _onSelectionChanged(eventArgs) {
        this.onSelectionChanged.emit(eventArgs);
    }
    ;
}
FamDiagramComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: FamDiagramComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
FamDiagramComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.2", type: FamDiagramComponent, selector: "fam-diagram", inputs: { navigationMode: "navigationMode", pageFitMode: "pageFitMode", minimalVisibility: "minimalVisibility", minimumVisibleLevels: "minimumVisibleLevels", orientationType: "orientationType", verticalAlignment: "verticalAlignment", arrowsDirection: "arrowsDirection", showExtraArrows: "showExtraArrows", extraArrowsMinimumSpace: "extraArrowsMinimumSpace", groupByType: "groupByType", alignBylevels: "alignBylevels", enableMatrixLayout: "enableMatrixLayout", minimumMatrixSize: "minimumMatrixSize", maximumColumnsInMatrix: "maximumColumnsInMatrix", hideGrandParentsConnectors: "hideGrandParentsConnectors", bevelSize: "bevelSize", elbowType: "elbowType", elbowDotSize: "elbowDotSize", emptyDiagramMessage: "emptyDiagramMessage", items: "items", annotations: "annotations", cursorItem: "cursorItem", highlightItem: "highlightItem", highlightGravityRadius: "highlightGravityRadius", selectedItems: "selectedItems", hasSelectorCheckbox: "hasSelectorCheckbox", selectCheckBoxLabel: "selectCheckBoxLabel", selectionPathMode: "selectionPathMode", neighboursSelectionMode: "neighboursSelectionMode", templates: "templates", defaultTemplateName: "defaultTemplateName", defaultLabelAnnotationTemplate: "defaultLabelAnnotationTemplate", hasButtons: "hasButtons", buttonsTemplate: "buttonsTemplate", normalLevelShift: "normalLevelShift", dotLevelShift: "dotLevelShift", lineLevelShift: "lineLevelShift", normalItemsInterval: "normalItemsInterval", dotItemsInterval: "dotItemsInterval", lineItemsInterval: "lineItemsInterval", cousinsIntervalMultiplier: "cousinsIntervalMultiplier", itemTitleFirstFontColor: "itemTitleFirstFontColor", itemTitleSecondFontColor: "itemTitleSecondFontColor", minimizedItemShapeType: "minimizedItemShapeType", linesColor: "linesColor", linesWidth: "linesWidth", linesType: "linesType", showNeigboursConnectorsHighlighted: "showNeigboursConnectorsHighlighted", highlightLinesColor: "highlightLinesColor", highlightLinesWidth: "highlightLinesWidth", highlightLinesType: "highlightLinesType", linesPalette: "linesPalette", calloutMaximumVisibility: "calloutMaximumVisibility", showCallout: "showCallout", calloutPlacementOffset: "calloutPlacementOffset", defaultCalloutTemplateName: "defaultCalloutTemplateName", calloutfillColor: "calloutfillColor", calloutBorderColor: "calloutBorderColor", calloutOffset: "calloutOffset", calloutCornerRadius: "calloutCornerRadius", calloutPointerWidth: "calloutPointerWidth", calloutLineWidth: "calloutLineWidth", calloutOpacity: "calloutOpacity", buttonsPanelSize: "buttonsPanelSize", groupTitlePanelSize: "groupTitlePanelSize", checkBoxPanelSize: "checkBoxPanelSize", groupTitlePlacementType: "groupTitlePlacementType", groupTitleOrientation: "groupTitleOrientation", groupTitleVerticalAlignment: "groupTitleVerticalAlignment", groupTitleHorizontalAlignment: "groupTitleHorizontalAlignment", groupTitleFontSize: "groupTitleFontSize", groupTitleFontFamily: "groupTitleFontFamily", groupTitleColor: "groupTitleColor", groupTitleFontWeight: "groupTitleFontWeight", groupTitleFontStyle: "groupTitleFontStyle", groupTitleTemplate: "groupTitleTemplate", levelTitlePanelSize: "levelTitlePanelSize", levelTitlePlacementType: "levelTitlePlacementType", levelTitlePlaceInside: "levelTitlePlaceInside", levelTitleOrientation: "levelTitleOrientation", levelTitleVerticalAlignment: "levelTitleVerticalAlignment", levelTitleHorizontalAlignment: "levelTitleHorizontalAlignment", levelTitleFontSize: "levelTitleFontSize", levelTitleFontFamily: "levelTitleFontFamily", levelTitleFontColor: "levelTitleFontColor", levelTitleColor: "levelTitleColor", levelTitleFontWeight: "levelTitleFontWeight", levelTitleFontStyle: "levelTitleFontStyle", levelTitleTemplate: "levelTitleTemplate", levelBackgroundTemplate: "levelBackgroundTemplate", distance: "distance", scale: "scale", minimumScale: "minimumScale", maximumScale: "maximumScale", showLabels: "showLabels", labelSize: "labelSize", labelOffset: "labelOffset", labelOrientation: "labelOrientation", labelPlacement: "labelPlacement", labelFontSize: "labelFontSize", labelFontFamily: "labelFontFamily", labelColor: "labelColor", labelFontWeight: "labelFontWeight", labelFontStyle: "labelFontStyle", enablePanning: "enablePanning", autoSizeMinimum: "autoSizeMinimum", autoSizeMaximum: "autoSizeMaximum", showFrame: "showFrame", frameInnerPadding: "frameInnerPadding", frameOuterPadding: "frameOuterPadding", padding: "padding" }, outputs: { onHighlightChanging: "onHighlightChanging", onHighlightChanged: "onHighlightChanged", onCursorChanging: "onCursorChanging", onCursorChanged: "onCursorChanged", onSelectionChanging: "onSelectionChanging", onSelectionChanged: "onSelectionChanged" }, usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<!-- root control panel -->\n<div #controlPanelRef\n  class=\"control-panel\"\n  [ngStyle]=\"controlPanelStyle\"\n  (keydown)=\"onKeyDown($event)\"\n  tabIndex=\"0\"\n>\n  <div *ngIf=\"framePlaceholder\"\n    #frameMousePanelRef\n    class=\"frame-mouse-panel\"\n    [ngStyle]=\"frameMousePanelStyle\"\n    (click)=\"onFrameClick($event)\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n  >\n    <div #framePlaceholderRef\n      class=\"frame-placeholder\" \n      [ngStyle]=\"framePlaceholderStyle\"\n    >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: framePlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div *ngIf=\"titlesPlaceholder\"\n    #titlesMousePanelRef\n    class=\"titles-mouse-panel\"\n    [ngStyle]=\"titlesMousePanelStyle\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n    (click)=\"onFrameClick($event)\"\n  >\n    <div #titlesPlaceholderRef\n      [ngStyle]=\"titlesPlaceholderStyle\"\n      class=\"titles-placeholder\"\n     >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: titlesPlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div\n    #scrollPanelRef\n    class=\"scroll-panel\"\n    [ngStyle]=\"scrollPanelStyle\"\n    (scroll)=\"onScroll($event)\"\n    [scrollLeft]=\"placeholderOffset ? placeholderOffset.x : undefined\"\n    [scrollTop]=\"placeholderOffset ? placeholderOffset.y : undefined\"\n  >\n    <div #mousePanelRef\n      class=\"mouse-panel\"\n      [ngStyle]=\"mousePanelStyle\"\n      (mousemove)=\"onMouseMove($event)\"\n      (click)=\"onClick($event)\"\n      (change)=\"onCheckboxChange($event)\"\n    >\n      <div #placeholderRef\n        class=\"placeholder\"\n        [ngStyle]=\"placeholderStyle\"\n      >\n        <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: placeholder}\"></ng-container>\n        <div *ngIf=\"calloutPlaceholder\"\n          #calloutPlaceholderRef\n          class=\"callout-placeholder\"\n          [ngStyle]=\"calloutPlaceholderStyle\"\n        >\n          <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: calloutPlaceholder}\"></ng-container>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!--Templates: -->\n<ng-template #layerTemplate let-placeholder>\n  <div *ngFor=\"let layer of placeholder.layers\" class=\"layer\">\n    <ng-container *ngIf=\"layer\">\n      <div *ngFor=\"let label of layer.labels\" class=\"label\" [ngStyle]= \"label.style\">\n        <rotated-text\n          [width]=\"label.width\"\n          [height]=\"label.height\"\n          [orientation]=\"label.orientation\"\n          [horizontalAlignment]=\"label.horizontalAlignment\"\n          [verticalAlignment]=\"label.verticalAlignment\"\n        >{{label.label}}</rotated-text>\n      </div>\n      <svg \n        *ngIf=\"layer.polylines.length > 0\"\n        attr.height.px=\"{{placeholder.size.height}}\"\n        attr.width.px=\"{{placeholder.size.width}}\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n        [ngStyle]=\"{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}\"\n      >\n        <path *ngFor=\"let path of layer.polylines\" [attr.d]=\"path.data\" [ngStyle]=\"path.style\"></path>\n      </svg>\n      <div *ngFor=\"let item of layer.items;\" class=\"template\" [ngStyle]=\"item.style\">\n        <ng-container [ngSwitch]=\"item.templateType\">\n          <ng-container *ngSwitchCase=\"'itemTemplate'\">\n            <bp-item [itemConfig]=\"item.context.context\" [itemTitleFirstFontColor]=\"item.context.itemTitleFirstFontColor\" [itemTitleSecondFontColor]=\"item.context.itemTitleSecondFontColor\"></bp-item>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'checkboxTemplate'\">\n            <bp-checkbox [id]=\"item.context.id\" [isSelected]=\"item.context.isSelected\" [label]=\"item.context.selectCheckBoxLabel\"></bp-checkbox>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'groupTitleTemplate'\">\n            <bp-group-title [options]=\"item.context\" [itemConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-group-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'cursorTemplate'\">\n            <bp-cursor [templateConfig]=\"item.context.templateConfig\"></bp-cursor>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'highlightTemplate'\">\n            <bp-highlight [templateConfig]=\"item.context.templateConfig\"></bp-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'dotHighlightTemplate'\">\n            <bp-dot-highlight [templateConfig]=\"item.context.templateConfig\"></bp-dot-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelTitleTemplate'\">\n            <bp-level-title [options]=\"item.context\" [annotationConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-level-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelBackgroundTemplate'\">\n            <bp-level-background [annotationConfig]=\"item.context.context\"></bp-level-background>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'labelAnnotationTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.title}}</div>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'annotationLabelTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.label}}</div>\n          </ng-container>\n          <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"item.templateRef; context: item.context\"></ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n</ng-template>\n", styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"], components: [{ type: RotatedText, selector: "rotated-text", inputs: ["width", "height", "orientation", "horizontalAlignment", "verticalAlignment"] }, { type: ItemComponent, selector: "bp-item", inputs: ["itemTitleFirstFontColor", "itemTitleSecondFontColor", "itemConfig"] }, { type: CheckboxComponent, selector: "bp-checkbox", inputs: ["id", "label", "isSelected"] }, { type: GroupTitleComponent, selector: "bp-group-title", inputs: ["options", "itemConfig", "width", "height"] }, { type: CursorComponent, selector: "bp-cursor", inputs: ["templateConfig"] }, { type: HighlightComponent, selector: "bp-highlight", inputs: ["templateConfig"] }, { type: DotHighlightComponent, selector: "bp-dot-highlight", inputs: ["templateConfig"] }, { type: LevelTitleComponent, selector: "bp-level-title", inputs: ["options", "annotationConfig", "width", "height"] }, { type: LevelBackgroundComponent, selector: "bp-level-background", inputs: ["annotationConfig"] }], directives: [{ type: i10.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i10.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i10.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i10.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i10.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i10.NgSwitchDefault, selector: "[ngSwitchDefault]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: FamDiagramComponent, decorators: [{
            type: Component,
            args: [{ selector: 'fam-diagram', template: "<!-- root control panel -->\n<div #controlPanelRef\n  class=\"control-panel\"\n  [ngStyle]=\"controlPanelStyle\"\n  (keydown)=\"onKeyDown($event)\"\n  tabIndex=\"0\"\n>\n  <div *ngIf=\"framePlaceholder\"\n    #frameMousePanelRef\n    class=\"frame-mouse-panel\"\n    [ngStyle]=\"frameMousePanelStyle\"\n    (click)=\"onFrameClick($event)\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n  >\n    <div #framePlaceholderRef\n      class=\"frame-placeholder\" \n      [ngStyle]=\"framePlaceholderStyle\"\n    >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: framePlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div *ngIf=\"titlesPlaceholder\"\n    #titlesMousePanelRef\n    class=\"titles-mouse-panel\"\n    [ngStyle]=\"titlesMousePanelStyle\"\n    (mousemove)=\"onFrameMouseMove($event)\"\n    (click)=\"onFrameClick($event)\"\n  >\n    <div #titlesPlaceholderRef\n      [ngStyle]=\"titlesPlaceholderStyle\"\n      class=\"titles-placeholder\"\n     >\n      <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: titlesPlaceholder}\"></ng-container>\n    </div>\n  </div>\n  <div\n    #scrollPanelRef\n    class=\"scroll-panel\"\n    [ngStyle]=\"scrollPanelStyle\"\n    (scroll)=\"onScroll($event)\"\n    [scrollLeft]=\"placeholderOffset ? placeholderOffset.x : undefined\"\n    [scrollTop]=\"placeholderOffset ? placeholderOffset.y : undefined\"\n  >\n    <div #mousePanelRef\n      class=\"mouse-panel\"\n      [ngStyle]=\"mousePanelStyle\"\n      (mousemove)=\"onMouseMove($event)\"\n      (click)=\"onClick($event)\"\n      (change)=\"onCheckboxChange($event)\"\n    >\n      <div #placeholderRef\n        class=\"placeholder\"\n        [ngStyle]=\"placeholderStyle\"\n      >\n        <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: placeholder}\"></ng-container>\n        <div *ngIf=\"calloutPlaceholder\"\n          #calloutPlaceholderRef\n          class=\"callout-placeholder\"\n          [ngStyle]=\"calloutPlaceholderStyle\"\n        >\n          <ng-container *ngTemplateOutlet=\"layerTemplate; context: {$implicit: calloutPlaceholder}\"></ng-container>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<!--Templates: -->\n<ng-template #layerTemplate let-placeholder>\n  <div *ngFor=\"let layer of placeholder.layers\" class=\"layer\">\n    <ng-container *ngIf=\"layer\">\n      <div *ngFor=\"let label of layer.labels\" class=\"label\" [ngStyle]= \"label.style\">\n        <rotated-text\n          [width]=\"label.width\"\n          [height]=\"label.height\"\n          [orientation]=\"label.orientation\"\n          [horizontalAlignment]=\"label.horizontalAlignment\"\n          [verticalAlignment]=\"label.verticalAlignment\"\n        >{{label.label}}</rotated-text>\n      </div>\n      <svg \n        *ngIf=\"layer.polylines.length > 0\"\n        attr.height.px=\"{{placeholder.size.height}}\"\n        attr.width.px=\"{{placeholder.size.width}}\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n        [ngStyle]=\"{width: placeholder.size.width + 'px', height: placeholder.size.height + 'px'}\"\n      >\n        <path *ngFor=\"let path of layer.polylines\" [attr.d]=\"path.data\" [ngStyle]=\"path.style\"></path>\n      </svg>\n      <div *ngFor=\"let item of layer.items;\" class=\"template\" [ngStyle]=\"item.style\">\n        <ng-container [ngSwitch]=\"item.templateType\">\n          <ng-container *ngSwitchCase=\"'itemTemplate'\">\n            <bp-item [itemConfig]=\"item.context.context\" [itemTitleFirstFontColor]=\"item.context.itemTitleFirstFontColor\" [itemTitleSecondFontColor]=\"item.context.itemTitleSecondFontColor\"></bp-item>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'checkboxTemplate'\">\n            <bp-checkbox [id]=\"item.context.id\" [isSelected]=\"item.context.isSelected\" [label]=\"item.context.selectCheckBoxLabel\"></bp-checkbox>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'groupTitleTemplate'\">\n            <bp-group-title [options]=\"item.context\" [itemConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-group-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'cursorTemplate'\">\n            <bp-cursor [templateConfig]=\"item.context.templateConfig\"></bp-cursor>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'highlightTemplate'\">\n            <bp-highlight [templateConfig]=\"item.context.templateConfig\"></bp-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'dotHighlightTemplate'\">\n            <bp-dot-highlight [templateConfig]=\"item.context.templateConfig\"></bp-dot-highlight>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelTitleTemplate'\">\n            <bp-level-title [options]=\"item.context\" [annotationConfig]=\"item.context.context\" [width]=\"item.context.width\" [height]=\"item.context.height\"></bp-level-title>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'levelBackgroundTemplate'\">\n            <bp-level-background [annotationConfig]=\"item.context.context\"></bp-level-background>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'labelAnnotationTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.title}}</div>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'annotationLabelTemplate'\">\n            <div class=\"label-annotation\">{{item.context.context.label}}</div>\n          </ng-container>\n          <ng-container *ngSwitchDefault>\n            <ng-container *ngTemplateOutlet=\"item.templateRef; context: item.context\"></ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n</ng-template>\n", styles: [".control-panel{position:relative;overflow:hidden;top:0px;left:0px;width:100%;height:100%;padding:0;margin-bottom:0;margin-right:0}.frame-mouse-panel{position:absolute;overflow:hidden}.frame-placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.titles-mouse-panel,.titles-placeholder{position:absolute;overflow:hidden}.scroll-panel{position:absolute;overflow:auto;-webkit-overflow-scrolling:touch}.mouse-panel{position:absolute;overflow:hidden}.placeholder{position:absolute;overflow:hidden;transform-origin:0 0}.callout-placeholder{position:absolute;overflow:visible}.layer{position:absolute;overflow:visible;left:0px;top:0px}.label{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box}.template{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;padding:0;margin:0}.label-annotation{position:absolute;overflow:visible;font-family:Trebuchet MS,Tahoma,Verdana,Arial,sans-serif;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-webkit-touch-callout:none;user-select:none;box-sizing:content-box;width:100%;text-align:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { navigationMode: [{
                type: Input
            }], pageFitMode: [{
                type: Input
            }], minimalVisibility: [{
                type: Input
            }], minimumVisibleLevels: [{
                type: Input
            }], orientationType: [{
                type: Input
            }], verticalAlignment: [{
                type: Input
            }], arrowsDirection: [{
                type: Input
            }], showExtraArrows: [{
                type: Input
            }], extraArrowsMinimumSpace: [{
                type: Input
            }], groupByType: [{
                type: Input
            }], alignBylevels: [{
                type: Input
            }], enableMatrixLayout: [{
                type: Input
            }], minimumMatrixSize: [{
                type: Input
            }], maximumColumnsInMatrix: [{
                type: Input
            }], hideGrandParentsConnectors: [{
                type: Input
            }], bevelSize: [{
                type: Input
            }], elbowType: [{
                type: Input
            }], elbowDotSize: [{
                type: Input
            }], emptyDiagramMessage: [{
                type: Input
            }], items: [{
                type: Input
            }], annotations: [{
                type: Input
            }], cursorItem: [{
                type: Input
            }], highlightItem: [{
                type: Input
            }], highlightGravityRadius: [{
                type: Input
            }], selectedItems: [{
                type: Input
            }], hasSelectorCheckbox: [{
                type: Input
            }], selectCheckBoxLabel: [{
                type: Input
            }], selectionPathMode: [{
                type: Input
            }], neighboursSelectionMode: [{
                type: Input
            }], templates: [{
                type: Input
            }], defaultTemplateName: [{
                type: Input
            }], defaultLabelAnnotationTemplate: [{
                type: Input
            }], hasButtons: [{
                type: Input
            }], buttonsTemplate: [{
                type: Input
            }], normalLevelShift: [{
                type: Input
            }], dotLevelShift: [{
                type: Input
            }], lineLevelShift: [{
                type: Input
            }], normalItemsInterval: [{
                type: Input
            }], dotItemsInterval: [{
                type: Input
            }], lineItemsInterval: [{
                type: Input
            }], cousinsIntervalMultiplier: [{
                type: Input
            }], itemTitleFirstFontColor: [{
                type: Input
            }], itemTitleSecondFontColor: [{
                type: Input
            }], minimizedItemShapeType: [{
                type: Input
            }], linesColor: [{
                type: Input
            }], linesWidth: [{
                type: Input
            }], linesType: [{
                type: Input
            }], showNeigboursConnectorsHighlighted: [{
                type: Input
            }], highlightLinesColor: [{
                type: Input
            }], highlightLinesWidth: [{
                type: Input
            }], highlightLinesType: [{
                type: Input
            }], linesPalette: [{
                type: Input
            }], calloutMaximumVisibility: [{
                type: Input
            }], showCallout: [{
                type: Input
            }], calloutPlacementOffset: [{
                type: Input
            }], defaultCalloutTemplateName: [{
                type: Input
            }], calloutfillColor: [{
                type: Input
            }], calloutBorderColor: [{
                type: Input
            }], calloutOffset: [{
                type: Input
            }], calloutCornerRadius: [{
                type: Input
            }], calloutPointerWidth: [{
                type: Input
            }], calloutLineWidth: [{
                type: Input
            }], calloutOpacity: [{
                type: Input
            }], buttonsPanelSize: [{
                type: Input
            }], groupTitlePanelSize: [{
                type: Input
            }], checkBoxPanelSize: [{
                type: Input
            }], groupTitlePlacementType: [{
                type: Input
            }], groupTitleOrientation: [{
                type: Input
            }], groupTitleVerticalAlignment: [{
                type: Input
            }], groupTitleHorizontalAlignment: [{
                type: Input
            }], groupTitleFontSize: [{
                type: Input
            }], groupTitleFontFamily: [{
                type: Input
            }], groupTitleColor: [{
                type: Input
            }], groupTitleFontWeight: [{
                type: Input
            }], groupTitleFontStyle: [{
                type: Input
            }], groupTitleTemplate: [{
                type: Input
            }], levelTitlePanelSize: [{
                type: Input
            }], levelTitlePlacementType: [{
                type: Input
            }], levelTitlePlaceInside: [{
                type: Input
            }], levelTitleOrientation: [{
                type: Input
            }], levelTitleVerticalAlignment: [{
                type: Input
            }], levelTitleHorizontalAlignment: [{
                type: Input
            }], levelTitleFontSize: [{
                type: Input
            }], levelTitleFontFamily: [{
                type: Input
            }], levelTitleFontColor: [{
                type: Input
            }], levelTitleColor: [{
                type: Input
            }], levelTitleFontWeight: [{
                type: Input
            }], levelTitleFontStyle: [{
                type: Input
            }], levelTitleTemplate: [{
                type: Input
            }], levelBackgroundTemplate: [{
                type: Input
            }], distance: [{
                type: Input
            }], scale: [{
                type: Input
            }], minimumScale: [{
                type: Input
            }], maximumScale: [{
                type: Input
            }], showLabels: [{
                type: Input
            }], labelSize: [{
                type: Input
            }], labelOffset: [{
                type: Input
            }], labelOrientation: [{
                type: Input
            }], labelPlacement: [{
                type: Input
            }], labelFontSize: [{
                type: Input
            }], labelFontFamily: [{
                type: Input
            }], labelColor: [{
                type: Input
            }], labelFontWeight: [{
                type: Input
            }], labelFontStyle: [{
                type: Input
            }], enablePanning: [{
                type: Input
            }], autoSizeMinimum: [{
                type: Input
            }], autoSizeMaximum: [{
                type: Input
            }], showFrame: [{
                type: Input
            }], frameInnerPadding: [{
                type: Input
            }], frameOuterPadding: [{
                type: Input
            }], padding: [{
                type: Input
            }], onHighlightChanging: [{
                type: Output
            }], onHighlightChanged: [{
                type: Output
            }], onCursorChanging: [{
                type: Output
            }], onCursorChanged: [{
                type: Output
            }], onSelectionChanging: [{
                type: Output
            }], onSelectionChanged: [{
                type: Output
            }] } });

class BasicPrimitivesService {
    constructor() { }
}
BasicPrimitivesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BasicPrimitivesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
BasicPrimitivesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BasicPrimitivesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BasicPrimitivesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class BasicPrimitivesModule {
}
BasicPrimitivesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BasicPrimitivesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BasicPrimitivesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BasicPrimitivesModule, declarations: [BaseDiagramComponent,
        OrgDiagramComponent,
        FamDiagramComponent,
        RotatedText,
        ItemComponent,
        CursorComponent,
        HighlightComponent,
        DotHighlightComponent,
        CheckboxComponent,
        GroupTitleComponent,
        LevelBackgroundComponent,
        LevelTitleComponent], imports: [CommonModule], exports: [OrgDiagramComponent,
        FamDiagramComponent,
        RotatedText] });
BasicPrimitivesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BasicPrimitivesModule, imports: [[
            CommonModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.2", ngImport: i0, type: BasicPrimitivesModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        BaseDiagramComponent,
                        OrgDiagramComponent,
                        FamDiagramComponent,
                        RotatedText,
                        ItemComponent,
                        CursorComponent,
                        HighlightComponent,
                        DotHighlightComponent,
                        CheckboxComponent,
                        GroupTitleComponent,
                        LevelBackgroundComponent,
                        LevelTitleComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        OrgDiagramComponent,
                        FamDiagramComponent,
                        RotatedText
                    ]
                }]
        }] });

class FamItemConfig {
    constructor(config = {}) {
        this.id = null;
        this.parents = [];
        this.title = null;
        this.description = null;
        this.image = null;
        this.context = null;
        this.itemTitleColor = "#4169e1";
        this.minimizedItemShapeType = null;
        this.groupTitle = null;
        this.groupTitleColor = "#4169e1";
        this.isActive = true;
        this.hasSelectorCheckbox = Enabled.Auto;
        this.hasButtons = Enabled.Auto;
        this.templateName = null;
        this.showCallout = Enabled.Auto;
        this.calloutTemplateName = null;
        this.label = null;
        this.showLabel = Enabled.Auto;
        this.labelSize = null;
        this.labelOrientation = TextOrientationType.Auto;
        this.labelPlacement = PlacementType.Auto;
        this.primaryParent = null;
        this.relativeItem = null;
        this.position = null;
        this.placementType = AdviserPlacementType.Right;
        this.matrixId = null;
        this.addToMatrix = true;
        Object.assign(this, config);
    }
}
;

class PaletteItemConfig {
    constructor(config = {}) {
        this.lineColor = "#c0c0c0";
        this.lineWidth = 1;
        this.lineType = LineType.Solid;
        Object.assign(this, config);
    }
}
;

class ConnectorAnnotationConfig {
    constructor(config = {}) {
        this.annotationType = AnnotationType.Connector;
        this.zOrderType = ZOrderType.Foreground;
        this.fromItem = null;
        this.toItem = null;
        this.connectorShapeType = ConnectorShapeType.OneWay;
        this.connectorPlacementType = ConnectorPlacementType.Offbeat;
        this.labelPlacementType = ConnectorLabelPlacementType.Between;
        this.offset = new Thickness(0, 0, 0, 0);
        this.lineWidth = 2;
        this.color = "#000000";
        this.lineType = LineType.Solid;
        this.selectItems = true;
        this.label = null;
        this.size = new Size(60, 30);
        Object.assign(this, config);
    }
}
;

class HighlightPathAnnotationConfig {
    constructor(config = {}) {
        this.annotationType = AnnotationType.HighlightPath;
        this.zOrderType = ZOrderType.Foreground;
        this.items = [];
        this.lineWidth = 2;
        this.color = "#ff0000";
        this.lineType = LineType.Solid;
        this.opacity = 1;
        this.showArrows = true;
        this.selectItems = false;
        Object.assign(this, config);
    }
}
;

class LabelAnnotationConfig {
    constructor(config = {}) {
        this.annotationType = AnnotationType.Label;
        this.fromItem = null;
        this.toItems = [];
        this.title = null;
        this.itemTitleColor = "#4169e1";
        this.templateName = null;
        Object.assign(this, config);
    }
}
;

class ShapeAnnotationConfig {
    constructor(config = {}) {
        this.annotationType = AnnotationType.Shape;
        this.zOrderType = ZOrderType.Auto;
        this.items = [];
        this.shapeType = ShapeType.Rectangle;
        this.offset = new Thickness(0, 0, 0, 0);
        this.lineWidth = 2;
        this.cornerRadius = "10%";
        this.opacity = 1;
        this.borderColor = null;
        this.fillColor = null;
        this.lineType = LineType.Solid;
        this.selectItems = false;
        this.label = null;
        this.labelSize = new Size(60, 30);
        this.labelPlacement = PlacementType.Auto;
        this.labelOffset = 4;
        Object.assign(this, config);
    }
}
;

class BackgroundAnnotationConfig {
    constructor(config = {}) {
        this.annotationType = AnnotationType.Background;
        this.items = [];
        this.includeChildren = false;
        this.zOrderType = ZOrderType.Auto;
        this.offset = new Thickness(18, 18, 18, 18);
        this.lineWidth = 2;
        this.opacity = 1;
        this.borderColor = null;
        this.fillColor = null;
        this.lineType = LineType.Solid;
        this.selectItems = false;
        Object.assign(this, config);
    }
}
;

/*
 * Public API Surface of ngx-basic-primitives
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AdviserPlacementType, AnnotationType, BackgroundAnnotationConfig, BasicPrimitivesModule, BasicPrimitivesService, ChildrenPlacementType, Colors, ConnectorAnnotationConfig, ConnectorLabelPlacementType, ConnectorPlacementType, ConnectorShapeType, ConnectorStyleType, ConnectorType, ElbowType, Enabled, FamDiagramComponent, FamItemConfig, GroupByType, HighlightPathAnnotationConfig, HorizontalAlignmentType, ItemType, LabelAnnotationConfig, LabelType, Layers, LevelAnnotationConfig, LineType, NavigationMode, NeighboursSelectionMode, OrgDiagramComponent, OrgItemConfig, OrientationType, PageFitMode, PaletteItemConfig, PlacementType, Rect, RenderingMode, RotatedText, SegmentType, SelectionPathMode, ShapeAnnotationConfig, ShapeType, SideFlag, Size, TemplateConfig, TextOrientationType, Thickness, UpdateMode, VectorRelationType, VerticalAlignmentType, Visibility, ZOrderType };
//# sourceMappingURL=ngx-basic-primitives.mjs.map
